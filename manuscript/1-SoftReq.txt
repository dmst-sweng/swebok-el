{mainmatter}

# Απαιτήσεις λογισμικού {#softreq}

## **Ακρωνύμια**

|ATDD   |Acceptance Test Driven Development |
|BDD    |Behavior Driven Development |
|CIA    |Confidentiality, Integrity, and Availability |
|FSM    |Functional Size Measurement |
|INCOSE |International Council on Systems Engineering |
|JAD    |Joint Application Development |
|JRP    |Joint Requirements Planning |
|RUP    |Rational Unified Process |
|SME    |Subject Matter Expert |
|SysML  |Systems Modeling Language |
|TDD    |Test Driven Development |
|UML	|Unified Modeling Language |

## **Εισαγωγή**

Οι απαιτήσεις λογισμικού θα πρέπει να εξετάζονται από δύο οπτικές.
Η πρώτη είναι ως έκφραση των αναγκών και περιορισμών ενός προϊόντος ή έργου
λογισμικού που συντελούν στην επίλυση ενός προβλήματος στον πραγματικό κόσμο.
Δεύτερη είναι εκείνη των δραστηριοτήτων που είναι απαραίτητες για την
ανάπτυξη και τη διατήρηση των απαιτήσεων για ένα προϊόν λογισμικού και για το
έργο που το κατασκευάζει.
Και οι δύο αυτές οπτικές παρουσιάζονται σε αυτό το γνωστικό πεδίο.

Εάν μια ομάδα δεν εκτελέσει καλά τον προσδιορισμό των απαιτήσεων, το έργο, το προϊόν
ή και τα δύο είναι πιθανό να υποστούν επιπλέον κόστη, καθυστερήσεις,
ακυρώσεις και ελαττώματα. Ένας λόγος είναι ότι κάθε απαίτηση προϊόντος λογισμικού
οδηγεί γενικά σε πολλές αποφάσεις σχεδιασμού.
Κάθε απόφαση σχεδίασης οδηγεί συνήθως σε πολλές αποφάσεις σε επίπεδο κώδικα.
Επίσης, κάθε απόφαση μπορεί να εμπεριέχει αρκετές δοκιμαστικές αποφάσεις.
Με άλλα λόγια, ο σωστός καθορισμός των απαιτήσεων είναι μια δουλειά υψηλού κινδύνου.
Αν δεν ανιχνευθούν και διορθωθούν έγκαιρα, απαιτήσεις που λείπουν,
έχουν παρερμηνευτεί ή είναι λανθασμένες μπορούν να προκαλέσουν εκθετικής φύσεως εργασίες
αναθεώρησης για να διορθωθούν.

Τα σχέδια λογισμικού στον πραγματικό κόσμο τείνουν να αντιμετωπίζουν δύο βασικά
προβλήματα που σχετίζονται με τις απαιτήσεις:
    1. ατέλεια: υπάρχουν απαιτήσεις ενδιαφερόμενων μερών που δεν αποκαλύπτονται και
    δεν επικοινωνούνται στους μηχανικούς λογισμικού,
    2. ασάφεια: οι απαιτήσεις επικοινωνούνται με τρόπο που επιδέχεται
    πολλαπλές ερμηνείες, με μόνο μια απο αυτές να είναι η σωστή.

Πέρα από τον προφανή, βραχυπρόθεσμο, ρόλο που έχουν οι απαιτήσεις στην αρχική κατασκευή
λογισμικού, παίζουν επίσης έναν λιγότερο αναγνωρισμένο, αλλά εξίσου σημαντικό
ρόλο στη μακροπρόθεσμη συντήρησή του. Όταν ένας μηχανικός λογισμικού λαμβάνει
λογισμικό χωρίς καμία υποστηρικτική τεκμηρίωση, έχει αρκετά μέσα για να καθορίσει
τι κάνει αυτός ο κώδικας, όπως να τον εκτελέσει, να τον περάσει από έναν αποσφαλματωτή,
να τον εκτελέσει χειροκίνητα, να τον αναλύσει στατικά, κλπ.
Η πρόκληση είναι να καθοριστεί τι ακριβώς είναι αυτός ο κώδικας *προορισμένος να κάνει*.
Αυτό που συνήθως αναφέρεται ως *σφάλμα* - αλλά καλύτερα αποκαλείται *ελάττωμα* - είναι
απλώς μια παρατηρήσιμη διαφορά μεταξύ αυτού που προορίζεται να κάνει το λογισμικό
και αυτού που πραγματικά κάνει. Ο ρόλος της τεκμηρίωσης των απαιτήσεων κατά τη
διάρκεια του κύκλου ζωής του λογισμικού είναι να καταγράψει και να επικοινωνήσει τις
προθέσεις στους μηχανικούς λογισμικού που συντηρούν τον κώδικα αλλά μπορεί
να μην είναι οι αρχικοί του συντάκτες.

Το γνωστικό πεδίο των Απαιτήσεων Λογισμικού αφορά την ανάπτυξη των απαιτήσεων
λογισμικού και τη διαχείρισή τους κατά τη διάρκεια της ζωής του λογισμικού.
Αυτό το γνωστικό πεδίο παρέχει κατανόηση ότι οι απαιτήσεις λογισμικού:

    * δεν είναι απαραίτητα μια διακριτή δραστηριότητα στο μπροστινό άκρο του κύκλου ζωής
    ανάπτυξης λογισμικού, αλλά μια διαδικασία που ξεκινά στην αρχή ενός έργου και συχνά
    συνεχίζεται να επανεκτιμάται καθ' όλη τη διάρκεια της ζωής του λογισμικού.
    * χρειάζεται να προσαρμόζονται στο περιβάλλον και στα πλαίσια του οργανισμού και του έργου.

Ο όρος *απαιτήσεις μηχανικής* χρησιμοποιείται ευρέως στο χώρο για
να υποδηλώσει τη συστηματική διαχείριση των απαιτήσεων.
Για λόγους συνέπειας, ο όρος *μηχανική* θα χρησιμοποιηθεί σε αυτό
το γνωστικό πεδίο αποκλειστικά για την τεχνολογία λογισμικού.

Το γνωστικό πεδίο των Απαιτήσεων Λογισμικού σχετίζεται στενά με τα γνωστικά πεδία
της Αρχιτεκτονικής Λογισμικού, του Σχεδιασμού Λογισμικού, της Κατασκευής Λογισμικού,
του Ελέγχου Λογισμικού και της Συντήρησης Λογισμικού. Σχετίζεται, ακόμα, με τον κλάδο
της μοντελοποίησης στο γνωστικό πεδίο των Μοντέλων και Μεθόδων Τεχνολογίας Λογισμικού,
καθώς ο καθορισμός απαιτήσεων υπό τη μορφή μοντέλων μπορεί να προσφέρει σημαντική αξία.

Αυτό το γνωστικό πεδίο σχετίζεται ακόμα, με το θέμα του Κύκλου Ζωής Λογισμικού που συμπεριλαμβάνεται
στο γνωστικό πεδίο των Διεργασιών Τεχνολογίας Λογισμικού, καθώς αυτό επικεντρώνεται
στο πως και το ποια δουλειά που σχετίζεται με τις απαιτήσεις, μπορεί και πρέπει
να γίνει, ενώ ο κύκλος ζωής του έργου καθορίζει το πότε θα γίνει αυτή η εργασία.
Για παράδειγμα, σε έναν κύκλο ζωής ενός έργου που ακολουθεί το μοντέλο του καταρράκτη,
όλη η εργασία των απαιτήσεων γίνεται ουσιαστικά σε μια διακριτή φάση απαιτήσεων και
αναμένεται να είναι ολοκληρωμένη σε σημαντικό βαθμό πριν οποιαδήποτε διεργασία
αρχιτεκτονικής, σχεδιασμού και κατασκευής προκύψει σε επόμενες φάσεις.
Σε μερικούς επαναλαμβανόμενους κύκλους ζωής, η αρχική, υψηλού επιπέδου εργασία
απαιτήσεων γίνεται κατά τη διάρκεια μιας φάσης έναρξης, και περαιτέρω λεπτομερείς
πληροφορίες δίνονται κατά τη διάρκεια μίας ή περισσότερων φάσεων επεξήγησης.
Σε έναν ευέλικτο (Agile) κύκλο ζωής, η εργασία πάνω στις απαιτήσεις γίνεται σταδιακά,
καθώς κατασκευάζεται κάθε επιπλέον στοιχείο λειτουργικότητας.

Τα τι και πως της εργασίας απαιτήσεων λογισμικού σε ένα έργο πρέπει να
καθορίζονται από τη φύση του κατασκευαζόμενου λογισμικού, όχι από
τον κύκλο ζωής κάτω από τον οποίο κατασκευάζεται.
Όσον αφορά την τεκμηρίωση των απαιτήσεων, καθώς αυτή απαθανατίζει και επικοινωνεί
την πρόθεση του λογισμικού, οι μεταγενέστεροι συντηρητές δεν πρέπει να μπορούν να
αναγνωρίσουν τον κύκλο ζωής που χρησιμοποιήθηκε στην προηγούμενη ανάπτυξη μόνο
από τη μορφή αυτών των απαιτήσεων.

Αυτό το γνωστικό πεδίο σχετίζεται επίσης, αλλά κάπως λιγότερο, με τα γνωστικά πεδία
της Διαχείρισης Σχηματισμών Λογισμικού, της Διοίκησης Τεχνολογίας Λογισμικού
και της Ποιότητας Λογισμικού. Οι προσεγγίσεις διαχείρισης σχηματισμών λογισμικού
μπορούν να εφαρμοστούν για την ανίχνευση και διαχείριση των απαιτήσεων, καθώς
η Ποιότητα Λογισμικού εξετάζει πόσο καλά διαμορφώνονται οι απαιτήσεις και η
Διοίκηση Τεχνολογίας Λογισμικού μπορεί να χρησιμοποιήσει την κατάσταση των
απαιτήσεων για να αξιολογήσει την ολοκλήρωση του έργου.

## **Κατανομή των θεμάτων για τις απαιτήσεις λογισμικού**

{id="fig-softreq-tree"}
![Σχήμα 1.1 Κατανομή των θεμάτων στο γνωστικό πεδίο Απαιτήσεις λογισμικού.](images/1-SoftReq.png)

Η κατανομή των θεμάτων για το γνωστικό πεδίο των απαιτήσεων λογισμικού
απεικονίζεται στο [Σχήμα 1.1](#fig-softreq-tree).

## **Βασικές αρχές στις απαιτήσεις λογισμικού**

### *Ορισμός μιας απαίτησης λογισμικού*

Επισήμως, μια απαίτηση λογισμικού έχει οριστεί ως:

    * μια προϋπόθεση ή δυνατότητα που χρειάζεται ένας χρήστης
    προκειμένου να επιλύσει ένα πρόβλημα ή να επιτύχει έναν στόχο
    * μια προϋπόθεση ή δυνατότητα που πρέπει να πληροί ή να διαθέτει
    ένα σύστημα ή ένα συστατικό αυτού, προκειμένου να ικανοποιεί ένα
    συμβόλαιο, ένα πρότυπο, μια προδιαγραφή ή ένα άλλο επίσημα
    επιβεβλημένο έγγραφο.
    * μια τεκμηριωμένη αναπαράσταση ή ικανότητα όπως αναφέρεται
    στο (1) ή (2) παραπάνω.

Αυτός ο επίσημος ορισμός επεκτείνεται σε αυτό το γνωστικό πεδίο,
περιλαμβάνοντας εκφράσεις των αναγκών και περιορισμών ενός έργου λογισμικού.

Ουσιαστικά, μια απαίτηση λογισμικού είναι μια ιδιότητα που πρέπει
να εξεταστεί με βάση κάποιο χαρακτηριστικό, ώστε να λύνει κάποιο πρόβλημα
στον πραγματικό κόσμο. Μπορεί να έχει ως σκοπό να αυτοματοποιήσει
ολόκληρη ή μέρος μιας εργασίας που υποστηρίζει τις επιχειρηματικές
πολιτικές και διαδικασίες ενός οργανισμού, να διορθώσει ελλείψεις
υπάρχοντος λογισμικού ή να ελέγξει μια συσκευή -- ονοματίζοντας μόνο κάποια
από τα πολλά προβλήματα για τα οποία είναι δυνατόν να υπάρξουν λύσεις λογισμικού.

Οι επιχειρησιακές πολιτικές και διαδικασίες, καθώς και οι λειτουργίες των
συσκευών είναι συχνά πολύπλοκες. Κατ' επέκταση, οι απαιτήσεις λογισμικού είναι
συνήθως ένας πολύπλοκος συνδυασμός απαιτήσεων από διάφορους ενδιαφερόμενους
φορείς σε διαφορετικά οργανωτικά επίπεδα, οι οποίοι είναι εμπλεκόμενοι ή
συνδεδεμένοι με κάποιο πτυχή του περιβάλλοντος στο οποίο θα λειτουργήσει
το λογισμικό.

Οι πελάτες και οι χρήστες συνήθως επιβάλλουν απαιτήσεις.
Ωστόσο, άλλοι τρίτοι φορείς, όπως οι ρυθμιστικές αρχές και σε ορισμένες
περιπτώσεις, ο οργανισμός του λογισμικού ή το ίδιο το έργο, ενδέχεται επίσης
να επιβάλουν απαιτήσεις.

### *Κατηγορίες Απαιτήσεων Λογισμικού*

Στο σχήμα 1.2 φαίνονται οι κατηγορίες απαιτήσεων λογισμικού που
προσδιορίζονται στο συγκεκριμένο γνωστικό πεδίο, σε συνδυασμό με τις σχέσεις
ανάμεσα σε αυτές τις κατηγορίες. Κάθε κατηγορία περιγράφεται περαιτέρω παρακάτω.

### *Απαιτήσεις προϊόντος λογισμικού και απαιτήσεις έργου λογισμικού*

Οι *απαιτήσεις προϊόντος λογισμικού* προσδιορίζουν την αναμενόμενη μορφή, εφαρμογή ή
λειτουργία του λογισμικού. Οι *απαιτήσεις έργου λογισμικού* - επίσης ονομαζόμενες
*απαιτήσεις διεργασίας ανάπτυξης* ή, μερικές φορές, *επιχειρηματικές απαιτήσεις* -
περιορίζουν το έργο που κατασκευάζει το λογισμικό. Οι απαιτήσεις έργου
περιορίζουν συνήθως το κόστος, το χρονοδιάγραμμα ή/και το προσωπικό, αλλά
μπορεί επίσης να περιορίζουν άλλες πτυχές ενός έργου λογισμικού, όπως τα
περιβάλλοντα ελέγχου, τη μεταφορά δεδομένων, την εκπαίδευση χρηστών και την
συντήρηση. Οι απαιτήσεις έργου λογισμικού μπορούν να καταγραφούν σε έναν χάρτη
έργου ή σε ένα άλλο, υψηλού επιπέδου, έγγραφο έναρξης έργου. Σχετίζονται
περισσότερο με τον τρόπο διοίκησης του έργου ή την επιλογή διαδικασίας κύκλου
ζωής που πρέπει να χρησιμοποιηθεί. Αυτό το γνωστικό πεδίο δεν παρουσιάζει
περαιτέρω τις απαιτήσεις έργου λογισμικού.

{id="fig-softreq-requirmentscategories"}

![Σχήμα 1.2 Κατηγορίες Απαιτήσεων Λογισμικού.](images/1.2-SoftReq.png)

### *Λειτουργικές απαιτήσεις*

Οι *λειτουργικές απαιτήσεις* καθορίζουν τις παρατηρήσιμες συμπεριφορές που πρέπει
να παρέχει το λογισμικό - πολιτικές που πρέπει να επιβάλλονται και διαδικασίες που
πρέπει να πραγματοποιούνται. Παραδείγματα πολιτικών στο λογισμικό τραπεζικής χρήσης
μπορεί να είναι «ένας λογαριασμός πρέπει πάντα να έχει τουλάχιστον έναν πελάτη ως
ιδιοκτήτη του», και «το υπόλοιπο σε έναν λογαριασμό δεν πρέπει ποτέ να είναι αρνητικό».
Παραδείγματα διαδικασιών μπορεί να καθορίζουν το νόημα της κατάθεσης χρημάτων σε έναν
λογαριασμό, της ανάληψης χρημάτων από έναν λογαριασμό και της μεταφοράς χρημάτων από
έναν λογαριασμό σε άλλον.

Ακόμη και το πιο τεχνικό (μη επιχειρησιακού προσανατολισμού) λογισμικό, όπως το
λογισμικό που υλοποιεί το πρωτόκολλο επικοινωνίας δικτύου Ελέγχου
Μετάδοσης/Πρωτοκόλλου Διαδικτύου (TCP/IP), έχει πολιτικές και διαδικασίες:
"μια θύρα θα πρέπει να μπορεί να υπάρχει με καμία, μία ή πολλές σχετικές
συνδέσεις, αλλά μία σύνδεση θα πρέπει να υπάρχει σε ακριβώς μία συσχετισμένη θύρα",
"οι αποδεκτές καταστάσεις μιας σύνδεσης θα πρέπει να είναι «ακρόαση»,
«syn sent», «εγκαθίδρυση», «κλείσιμο», ..." και "εάν ο χρόνος ζωής
ενός Τμήματος φτάσει στο μηδέν, αυτό το Τμήμα θα διαγραφεί".

### *Μη λειτουργικές απαιτήσεις*

Οι *μη λειτουργικές απαιτήσεις* περιορίζουν κατά κάποιον τρόπο τις τεχνολογίες
που πρέπει να χρησιμοποιηθούν κατά την υλοποίηση. Προκύπτουν, λοιπόν, ερωτήματα
όπως: Ποιες υπολογιστικές πλατφόρμες θα χρησιμοποιηθούν; Ποια ή ποιες μηχανές
βάσεων δεδομένων; Πόσο ακριβή θα πρέπει να είναι τα δεδομένα; Με ποια ταχύτητα
θα πρέπει να παρουσιάζονται τα αποτελέσματα; Πόσες εγγραφές ενός συγκεκριμένου
τύπου που πρέπει να αποθηκευτούν; Ορισμένες μη λειτουργικές απαιτήσεις μπορεί
να αναφέρονται στη λειτουργία του λογισμικού.

Οι μη λειτουργικές απαιτήσεις μπορούν να χωριστούν περαιτέρω σε περιορισμούς
τεχνολογίας και περιορισμούς ποιότητας υπηρεσιών.

### *Περιορισμοί τεχνολογίας*

Αυτές οι απαιτήσεις επιβάλλουν - ή απαγορεύουν - τη χρήση συγκεκριμένων
τεχνολογιών αυτοματισμού με συγκεκριμένα ονόματα ή ορισμένες υποδομές.
Παραδείγματα αυτών των απαιτήσεων είναι η απαίτηση για τη χρήση συγκεκριμένων
υπολογιστικών πλατφορμών (π.χ. Windows™, MacOS™, Android OS™, iOS™), γλωσσών
προγραμματισμού (π.χ. Java, C++, C#, Python), συμβατότητας με συγκεκριμένους
περιηγητές ιστού (π.χ. Chrome™, Safari™, Edge™), συγκεκριμένες μηχανές βάσεων
δεδομένων (π.χ. Oracle™, SQL Server™, MySQL™) και γενικές τεχνολογίες
(π.χ. Reduced Instruction Set Computer (RISC), Relational Database).
Μια απαίτηση που απαγορεύει τη χρήση δεικτών (pointers) θα μπορούσε να
είναι ένα άλλο παράδειγμα.

### *Περιορισμοί ποιότητας υπηρεσιών*

Αυτές οι απαιτήσεις δεν περιορίζουν τη χρήση συγκεκριμένων τεχνολογιών
με συγκεκριμένα ονόματα. Αντίθετα, καθορίζουν αποδεκτά επίπεδα απόδοσης
που πρέπει να έχει μια αυτοματοποιημένη λύση.
Παραδείγματα αυτών είναι ο χρόνος απόκρισης, ο ρυθμός επεξεργασίας,
η ακρίβεια, η αξιοπιστία και η επεκτασιμότητα.
Πρότυπο ISO/IEC 25010: "Μηχανική συστημάτων και λογισμικού - Απαιτήσεις
ποιότητας και αξιολόγηση συστημάτων και λογισμικού (SQuaRE) - Μοντέλα ποιότητας
συστημάτων και λογισμικού" περιλαμβάνει μια μεγάλη λίστα των ειδών
των ποιοτικών χαρακτηριστικών υπηρεσίας που μπορεί να είναι σχετικά με
το λογισμικό. Η ασφάλεια είναι επίσης ένα ιδιαίτερα σημαντικό θέμα όπου οι
απαιτήσεις τείνουν να παραβλέπονται. (Για λεπτομέρειες σχετικά με τα είδη
των συγκεκριμένων απαιτήσεων ασφαλείας που πρέπει να ληφθούν υπόψη,
δείτε τo γνωστικό πεδίο ασφαλείας.)

### *Γιατί κατηγοριοποιούμε τις απαιτήσεις με αυτόν τον τρόπο;*

Η κατηγοριοποίηση των απαιτήσεων με αυτόν τον τρόπο είναι
χρήσιμη για τους εξής λόγους:

    * Οι απαιτήσεις σε μία κατηγορία τείνουν να προέρχονται
    από διαφορετικές πηγές παρά από άλλες κατηγορίες.
    * Οι τεχνικές απόκτησης συχνά διαφέρουν ανάλογα με την πηγή.
    * Οι τεχνικές ανάλυσης διαφέρουν ανάλογα με την κατηγορία.
    * Οι τεχνικές προδιαγραφής διαφέρουν ανάλογα με την κατηγορία.
    * Οι αρμόδιοι επαλήθευσης διαφέρουν ανάλογα με την κατηγορία.
    * Οι διαφορετικές κατηγορίες επηρεάζουν το αποτέλεσμα του λογισμικού
    με διαφορετικούς τρόπους.

Επιπλέον, η οργάνωση των απαιτήσεων σε αυτές τις κατηγορίες
είναι επωφελής με τους ακόλουθους τρόπους:

    * Η πολυπλοκότητα μπορεί να διαχειρίζεται καλύτερα επειδή διαφορετικές
    περιοχές μπορούν να αντιμετωπίζονται ξεχωριστά. Δηλαδή, Οι μηχανικοί
    λογισμικού μπορούν να αντιμετωπίζουν τις πολιτικές και τις διαδικαστικές
    πολυπλοκότητες χωρίς να ανησυχούν ταυτόχρονα για τα ζητήματα της
    τεχνολογίας αυτοματοποίησης (και αντίστροφα).
    Ένα μεγάλο πρόβλημα χωρίζεται σε δύο μικρότερα.
    Αυτή είναι η κλασική διαχείριση της πολυπλοκότητας με τη
    μέθοδο *διαίρει και βασίλευε*.

    * Διακριτές περιοχές ειδίκευσης μπορούν να απομονωθούν· οι ενδιαφερόμενοι
    φορείς, και όχι οι μηχανικοί λογισμικού, είναι οι ειδικοί στις πολιτικές
    και διαδικασίες που πρέπει να αυτοματοποιηθούν. Οι μηχανικοί λογισμικού,
    και όχι οι ενδιαφερόμενοι φορείς, είναι οι ειδικοί της τεχνολογίας.
    Όταν δίνονται σε έναν επαγγελματία της επιχείρησης συνεχόμενες λειτουργικές
    και μη λειτουργικές απαιτήσεις για επισκόπηση ή επαλήθευση, μπορεί "να τα
    παρατήσει" επειδή δεν κατανοεί - ή ακόμη και δεν ενδιαφέρεται για -
    τα ζητήματα της τεχνολογίας. Ενώ, ο ειδικός στις απαιτήσεις επιθεωρητής μπορεί
    να επικεντρωθεί μόνο στο υποσύνολο των απαιτήσεων που τον αφορούν.

Το *Τέλειο Φίλτρο Τεχνολογίας* (Perfect Technology Filter) που περιγράφεται,
βοηθά να διαχωριστούν οι λειτουργικές από τις μη λειτουργικές απαιτήσεις. Με
απλά λόγια, οι λειτουργικές απαιτήσεις είναι αυτές που θα χρειαζόταν να
δηλωθούν ακόμα και αν υπήρχε ένας υπολογιστής με άπειρη ταχύτητα, απεριόριστη
μνήμη, μηδενικό κόστος, χωρίς αποτυχίες, κλπ., πάνω στον οποίο θα μπορούσε να
κατασκευαστεί το λογισμικό. Όλες οι άλλες απαιτήσεις του προϊόντος λογισμικού
είναι περιορισμοί στις τεχνολογίες αυτοματοποίησης και επομένως είναι μη λειτουργικές.

Τα μεγάλα συστήματα συχνά καλύπτουν περισσότερους από έναν τομέα
θεμάτων ή πεδίων. Η αναδρομική σχεδίαση δείχνει
πώς οι μη λειτουργικές απαιτήσεις σε έναν γονικό τομέα μπορούν να γίνουν,
ή να προκαλέσουν, λειτουργικές απαιτήσεις σε έναν τομέα "παιδί".
Για παράδειγμα, μια μη λειτουργική απαίτηση σχετικά με την ασφάλεια του
χρήστη σε έναν γονικό τομέα τραπεζικών εργασιών μπορεί να γίνει, ή να
προκαλέσει λειτουργικές απαιτήσεις σε έναν "παιδικό" τομέα ασφαλείας.
Αντίστοιχα, οι διασταυρούμενες μη λειτουργικές απαιτήσεις σχετικά με τον
έλεγχο και τη διαχείριση συναλλαγών σε έναν γονικό τομέα τραπεζικών εργασιών
μπορούν να γίνουν, ή να προκαλέσουν λειτουργικές απαιτήσεις σε έναν "παιδικό"
τομέα ελέγχου και σε έναν "παιδικό" τομέα συναλλαγών. Η ανάλυση μεγάλων
συστημάτων σε ένα σύνολο σχετικών τομέων μειώνει σημαντικά την πολυπλοκότητα.

### *Απαιτήσεις συστήματος και λογισμικού*

Το Διεθνές συμβούλιο για την τεχνολογία λογισμικού και συστημάτων (INCOSE)
ορίζει ένα *σύστημα* "ως έναν αλληλεπιδραστικό συνδυασμό στοιχείων για την
επίτευξη ενός καθορισμένου στόχου. Αυτά τα στοιχεία περιλαμβάνουν το υλικό
του υπολογιστή (hardware), το λογισμικό (software), το υλικο-λογισμικό
(firmware), τους ανθρώπους, τις πληροφορίες, τις τεχνικές, τις εγκαταστάσεις,
τις υπηρεσίες, καθώς και άλλα στοιχεία υποστήριξης".

Σε ορισμένες περιπτώσεις, είναι χρήσιμο ή απαραίτητο να διαχωρίζονται οι
απαιτήσεις συστήματος από τις απαιτήσεις λογισμικού. Οι απαιτήσεις συστήματος
ισχύουν για μεγαλύτερα συστήματα - για παράδειγμα, ένα αυτόνομο όχημα.
Οι απαιτήσεις λογισμικού ισχύουν μόνο για ένα στοιχείο λογισμικού σε αυτό
το μεγαλύτερο σύστημα. Ορισμένες απαιτήσεις λογισμικού μπορεί να προέρχονται
από απαιτήσεις συστήματος. Σε άλλες περιπτώσεις,
το λογισμικό αποτελεί αυτό καθαυτό το σύστημα ενδιαφέροντος, και το υλικό
και το σύστημα υποστήριξης θεωρούνται ως πλατφόρμα ή υποδομή, ώστε οι
απαιτήσεις συστήματος να είναι κυρίως απαιτήσεις λογισμικού.

### *Παραγόμενες απαιτήσεις*

Στην πράξη, οι *απαιτήσεις* μπορούν να είναι ευαίσθητες στο πλαίσιο και να
εξαρτώνται από την οπτική γωνία. Ένα εξωτερικό ενδιαφερόμενο μέρος μπορεί να
επιβάλει μια απαίτηση εύρους και αυτό θα ήταν μια απαίτηση για ολόκληρο το
έργο - ακόμη κι αν αυτό το έργο περιλαμβάνει εκατοντάδες μηχανικούς λογισμικού.
Η απόφαση ενός αρχιτέκτονα να χρησιμοποιήσει ένα στυλ αρχιτεκτονικής αγωγών
και φίλτρων δεν θα ήταν μια απαίτηση από την οπτική γωνία των ενδιαφερομένων
στο συνολικό έργο, αλλά μια απόφαση σχεδιασμού. Αλλά η ίδια αυτή απόφαση,
όταν αντιμετωπίζεται από την οπτική γωνία μιας υποομάδας που είναι υπεύθυνη
για την κατασκευή ενός συγκεκριμένου φίλτρου, θα θεωρείται απαίτηση.

Η αεροδιαστημική βιομηχανία χρησιμοποιεί εδώ και καιρό τον όρο *παραγόμενη
απαίτηση* για να σημαίνει μια απαίτηση που δεν δόθηκε από εξωτερικό
ενδιαφερόμενο στο σύνολο του έργου, αλλά επιβλήθηκε μέσα στη μεγαλύτερη
ομάδα ανάπτυξης. Η αρχιτεκτονική απόφαση των αγωγών και φίλτρων του
αρχιτέκτονα ταιριάζει σε αυτόν τον ορισμό. Αυτή η επιλογή θα θεωρείτο
μια απόφαση σχεδιασμού από την άποψη των εξωτερικών ενδιαφερομένων,αλλά ως
απαίτηση για τις υποομάδες που είναι υπεύθυνες για την ανάπτυξη κάθε φίλτρου.

### *Δραστηριότητες απαιτήσεων λογισμικού*

{id="fig-softreq-requirementsactivities"}

![Σχήμα 1.3 Δραστηριότητες απαιτήσεων λογισμικού.](images/1.3-SoftReq.png)

Στο σχήμα 1.3 παρουσιάζονται οι δραστηριότητες ανάπτυξης και
διαχείρισης απαιτήσεων.

Η ανάπτυξη απαιτήσεων, συνολικά, μπορεί να θεωρηθεί ως "επίτευξη συμφωνίας
για το τι λογισμικό πρέπει να κατασκευαστεί". Αντίθετα, η διαχείριση
απαιτήσεων μπορεί να θεωρηθεί ως "διατήρηση αυτής της συμφωνίας στον χρόνο".
Κάθε δραστηριότητα παρουσιάζεται σε αυτό το γνωστικό πεδίο. Οι δραστηριότητες
ανάπτυξης απαιτήσεων παρουσιάζονται ως ξεχωριστά θέματα, με τη διαχείριση
απαιτήσεων να παρουσιάζεται ως ένα μόνο θέμα.

## **Εκμαίευση απαιτήσεων**

Ο στόχος της εκμαίευσης απαιτήσεων είναι να εντοπιστούν οι υποψήφιες απαιτήσεις.
Αυτή η διαδικασία ονομάζεται επίσης *σύλληψη απαιτήσεων*, *ανακάλυψη
απαιτήσεων* ή *απόκτηση απαιτήσεων*. Όπως αναφέρθηκε προηγουμένως, ένα πρόβλημα
στην εργασία με απαιτήσεις σε πραγματικά έργα λογισμικού είναι η έλλειψη
ολοκλήρωσης. Αυτό μπορεί να οφείλεται σε ανεπαρκή εκμαίευση. Παρόλο που δεν
υπάρχει εγγύηση για μια πλήρη συλλογή απαιτήσεων, μια καλά εκτελεσμένη σύλληψη
βοηθά στο να μειωθεί η έλλειψη ολοκλήρωσης.

### *Πηγές απαιτήσεων*

Οι απαιτήσεις προέρχονται - μπορούν να εκμαιευτούν - από πολλές
διαφορετικές πηγές. Όλες οι δυνητικές πηγές απαιτήσεων πρέπει να αναγνωριστούν
και να αξιολογηθούν. Ένα *ενδιαφερόμενο μέρος* μπορεί να οριστεί ως
οποιοσδήποτε άνθρωπος, ομάδα ή οργανισμός που:

    * εμπλέκεται ενεργά στο έργο,
    * επηρεάζεται από το αποτέλεσμα του έργου,
    * μπορεί να επηρεάσει το αποτέλεσμα του έργου.

Οι τυπικοί ενδιαφερόμενοι για τα έργα λογισμικού περιλαμβάνουν, αλλά δεν
περιορίζονται μόνο στα ακόλουθα:

    * πελάτες - τόσο εκείνοι που πληρώνουν για το λογισμικό που θα κατασκευαστεί
    (π.χ. διοίκηση οργανισμού) (clients), όσο και εκείνοι που αποφασίζουν εάν
    ένα προϊόν λογισμικού θα τεθεί σε λειτουργία (customers),
    * χρήστες - εκείνοι που αλληλεπιδρούν άμεσα ή έμμεσα με το λογισμικό
    οι χρήστες μπορούν συχνά να χωριστούν σε διακριτές κατηγορίες χρηστών που
    διαφέρουν στη συχνότητα χρήσης, τις εργασίες που εκτελούν, το επίπεδο
    εξειδίκευσης και γνώσης, το επίπεδο προνομίων κ.λπ.,
    * ειδικοί πάνω στο θέμα (SMEs),
    * προσωπικό λειτουργίας,
    * προσωπικό πρώτου επιπέδου υποστήριξης προϊόντος,
    * σχετικά επαγγελματικά σώματα,
    * κανονιστικές αρχές,
    * ομάδες ειδικού ενδιαφέροντος,
    * άνθρωποι που μπορεί να επηρεαστούν αρνητικά εάν το έργο είναι επιτυχημένο,
    * προγραμματιστές.

Οι *κατηγορίες των ενδιαφερομένων*Απαιτήσεις είναι ομάδες ενδιαφερομένων που έχουν
παρόμοιες απόψεις και ανάγκες. Η εργασία σε ένα έργο λογισμικού με
κατηγορίες ενδιαφερομένων αντί για ατομικούς ενδιαφερομένους μπορεί
να παράγει σημαντική, πρόσθετη κατανόηση.

Πολλά έργα ωφελούνται από τη διενέργεια μιας ανάλυσης ενδιαφερομένων μερών για
την αναγνώριση όσο το δυνατόν περισσότερων ενδιαφερομένων μερών. Αυτό μειώνει
την πιθανότητα να υπάρχει μεροληψία στις απαιτήσεις υπέρ των ενδιαφερομένων
μερών που εκπροσωπούνται καλύτερα και κατά των λιγότερο καλά
εκπροσωπούμενων ενδιαφερομένων μερών. Η ανάλυση αυτή μπορεί επίσης
να καθοδηγεί τη διαπραγμάτευση και την επίλυση συγκρούσεων όταν οι απαιτήσεις
από μια κατηγορία ενδιαφερομένων συγκρούονται με απαιτήσεις από άλλη.

Οι απαιτήσεις δεν προέρχονται απαραίτητα μόνο από ανθρώπους.
Άλλες πηγές απαιτήσεων μπορούν να είναι:

    * Η τεκμηρίωση, όπως οι απαιτήσεις για προηγούμενες εκδόσεις, οι διακηρύξεις
    αποστολής, το συνολικό σχέδιο λειτουργίας,
    * Άλλα συστήματα,
    * το ευρύτερο επιχειρησιακό περιβάλλον συμπεριλαμβανομένων των πολιτικών και
    των διαδικασιών του οργανισμού,
    * Το περιβάλλον υπολογιστικών συστημάτων.

### *Συνήθεις τεχνικές εκμαίευσης απαιτήσεων*

Μπορούν να χρησιμοποιηθούν πολλές τεχνικές για την εκμαίευση απαιτήσεων από
τα ενδιαφερόμενα μέρη. Ορισμένες τεχνικές λειτουργούν καλύτερα με συγκεκριμένες
κατηγορίες ενδιαφερομένων μερών. Οι συνηθισμένες τεχνικές ανάκτησης απαιτήσεων
από ενδιαφερόμενα μέρη περιλαμβάνουν τα ακόλουθα:

    * συνεντεύξεις,
    * συναντήσεις, πιθανότατα που συμπεριλαμβάνουν brainstorming,
    * Από κοινού Ανάπτυξη Εφαρμογών (JAD), Από κοινού Σχεδιασμός Απαιτήσεων (JRP)
    και άλλα οργανωμένα εργαστήρια,
    * ανάλυση πρωτοκόλλου,
    * ομάδες εστίασης,
    * ερωτηματολόγια και έρευνες αγοράς,
    * διερευνητικά πρωτότυπα, συμπεριλαμβανομένων των πρωτοτύπων διεπαφών χρήστη
    χαμηλής και υψηλής πιστότητας,
    * καταγραφή ιστοριών χρήστη.

Η εκμαίευση μπορεί να είναι δύσκολη και ο μηχανικός λογισμικού πρέπει να
γνωρίζει ότι (για παράδειγμα) οι χρήστες μπορεί να δυσκολεύονται να περιγράψουν
τις εργασίες τους, να αφήνουν αναπάντητες σημαντικές πληροφορίες ή να μην
είναι πρόθυμοι ή σε θέση να συνεργαστούν. Η εκμαίευση δεν είναι μια παθητική
δραστηριότητα. Ακόμα κι αν υπάρχουν συνεργάσιμοι και εύληπτοι ενδιαφερόμενοι,
ο μηχανικός λογισμικού πρέπει να εργαστεί σκληρά για να εκμαιεύσει τις σωστές
πληροφορίες. Πολλές απαιτήσεις προϊόντος είναι σιωπηρές ή μπορούν να βρεθούν
μόνο σε πληροφορίες που δεν έχουν συλλεχθεί ακόμα.

Οι απαιτήσεις μπορούν επίσης να αντληθούν από διάφορες πηγές πέρα από τα
ενδιαφερόμενα μέρη. Τέτοιες πηγές και τεχνικές περιλαμβάνουν τα εξής:

    * προηγούμενες εκδόσεις του συστήματος,
    * βάση δεδομένων παρακολούθησης ατελειών για προηγούμενες εκδόσεις του
    συστήματος,
    * συστήματα που επικοινωνούν με το σύστημα που βρίσκεται υπό ανάπτυξη,
    * ανταγωνιστικό benchmarking,
    * βιβλιογραφική έρευνα,
    * Ο Οίκος Ποιότητας (House of Quality) της Εξάπλωσης της Λειτουργίας
    Ποιότητας (QFD),
    * παρατήρηση, όπου ο μηχανικός λογισμικού μελετά την εργασία και το
    περιβάλλον μέσα στο οποίο αυτή πραγματοποιείται,
    * μαθητεία, όπου ο μηχανικός λογισμικού μαθαίνει κάνοντας τη δουλειά,
    * περιγραφές σεναρίων χρήσης,
    * αποσύνθεση (π.χ. ικανότητες σε epics σε δυνατότητες σε stories),
    * ανάλυση εργασιών,
    * σχεδιαστική σκέψη (συναίσθηση, καθορισμός, συλλογισμός, πρωτότυπα, δοκιμές),
    * Πρότυπο ISO/IEC 25010: "Μηχανική συστημάτων και λογισμικού - Απαιτήσεις
    ποιότητας και αξιολόγηση συστημάτων και λογισμικού (SQuaRE) - Ποιοτικά μοντέλα
    συστημάτων και λογισμικού",
    * απαιτήσεις ασφαλείας, όπως συζητούνται στο γνωστικό πεδίο της Ασφάλειας,
    * ισχύοντα πρότυπα και κανονισμοί.

## **Ανάλυση απαιτήσεων** {#req-analysis}

Οι απαιτήσεις σπάνια εξάγονται στην τελική τους μορφή. Συνήθως απαιτείται
περαιτέρω έρευνα για να αποκαλυφθούν οι πλήρεις και πραγματικές απαιτήσεις
που παρουσιάζονται από τις πληροφορίες που έχουν αρχικά συλλεχθεί. Η ανάλυση
απαιτήσεων βοηθά τους προγραμματιστές λογισμικού να κατανοήσουν τη σημασία και
τις συνέπειες των προτεινόμενων απαιτήσεων, τόσο ατομικά όσο και στο πλαίσιο
του ευρύτερου συνόλου απαιτήσεων.

### *Βασική ανάλυση απαιτήσεων*

Η παρακάτω λίστα επιθυμητών ιδιοτήτων των απαιτήσεων μπορεί να καθοδηγήσει τη
βασική ανάλυση απαιτήσεων. Ο μηχανικός λογισμικού προσπαθεί να καθιερώσει
οποιαδήποτε από αυτές τις ιδιότητες, σε περίπτωση που δεν εφαρμόζονται ακόμα.
Κάθε απαίτηση θα πρέπει:

    * να είναι ξεκάθαρη (ερμηνεύσιμη με μόνο έναν τρόπο)
    * να είναι ελέγξιμη (να μπορεί να ποσοτικοποιηθεί), που σημαίνει ότι η
    συμμόρφωση ή η μη συμμόρφωση μπορεί να αποδειχθεί με σαφήνεια.
    * να είναι δεσμευτική, που σημαίνει ότι οι πελάτες είναι διατεθειμένοι να
    πληρώσουν για αυτήν και απρόθυμοι να μην την έχουν
    * να αντιπροσωπεύει πραγματικές ανάγκες των ενδιαφερομένων μερών
    * να χρησιμοποιεί το λεξιλόγιο των ενδιαφερομένων μερών
    * να είναι αποδεκτή από όλα τα ενδιαφερόμενα μέρη

Η συλλογή των απαιτήσεων συνολικά θα πρέπει να είναι:

    * ολοκληρωμένη, δηλαδή να ανταποκρίνεται επαρκώς στις συνθήκες των ορίων και
    των εξαιρέσεων και τις ανάγκες ασφάλειας
    * εσωτερικά συνεπής, δηλαδή καμία απαίτηση δεν συγκρούεται με κάποια άλλη
    * εξωτερικά συνεπής, δηλαδή καμία απαίτηση δεν συγκρούεται με οποιοδήποτε
    πηγαίο υλικό
    * εφικτή, δηλαδή μπορεί να δημιουργηθεί μια λειτουργική, οικονομικά αποδοτική
    λύση εντός των περιορισμών του κόστους, του χρονοδιαγράμματος, του προσωπικού
    και άλλων περιορισμών

Σε ορισμένες περιπτώσεις, μια απαίτηση που έχει εκμαιευτεί αντιπροσωπεύει μια
λύση προς υλοποίηση αντί για το πραγματικό πρόβλημα που πρέπει να επιλυθεί.
Αυτό κινδυνεύει να οδηγήσει στην υλοποίηση μιας μη βέλτιστης λύσης.
Η τεχνική των "5 γιατί" (5-whys) περιλαμβάνει το επαναλαμβανόμενο ερώτημα
"Γιατί είναι αυτή η απαίτηση;" για να συγκλίνει στο πραγματικό πρόβλημα.
Η επανάληψη σταματά όταν η απάντηση είναι "Εάν αυτό δεν γίνει, τότε το πρόβλημα
του ενδιαφερόμενου μέρους δεν έχει λυθεί." Συχνά, το πραγματικό πρόβλημα
επιλύεται μετά από δύο ή τρεις κύκλους, αλλά η τεχνική ονομάζεται "5 γιατί" για
να ενθαρρύνει τους μηχανικούς να την επαναλαμβάνουν όσο το δυνατόν περισσότερο.

### *Οικονομικά των περιορισμών της ποιότητας υπηρεσιών*

Οι περιορισμοί της ποιότητας υπηρεσιών μπορούν να είναι ιδιαίτερα
προκλητικοί. Αυτό συμβαίνει γενικά επειδή οι μηχανικοί δεν τους λαμβάνουν
υπόψη από οικονομική σκοπιά. Η εικόνα 1.4 απεικονίζει την οικονομική
προοπτική ενός τυπικού περιορισμού ποιότητας υπηρεσιών, όπως η χωρητικότητα,
η επεξεργαστική ικανότητα και η αξιοπιστία, όπου η αξία αυξάνεται με το
επίπεδο απόδοσης. Αυτή η καμπύλη αντανακλάται κατακόρυφα για περιορισμούς
ποιότητας υπηρεσιών, των οποίων η αξία μειώνεται καθώς το επίπεδο απόδοσης
αυξάνεται (παραδείγματα θα μπορούσαν να είναι ο χρόνος απόκρισης και ο μέσος
χρόνος επισκευής).

{id="fig-softreq-valuefunction"}

![Σχήμα 1.4 Η αξία ως συνάρτηση του επιπέδου επίδοσης.](images/1.4-SoftReq.png)

Στο σχετικό εύρος επιπέδων απόδοσης, τα ενδιαφερόμενα μέρη έχουν μια αντίστοιχη
αξία εάν το σύστημα αποδίδει σε αυτό το επίπεδο. Η καμπύλη αξίας έχει δύο
σημαντικά σημεία:

    1. Σημείο τέλειας απόδοσης - Αυτό είναι το πλέον ευνοϊκό επίπεδο απόδοσης,
       πέρα από το οποίο δεν υπάρχει επιπλέον όφελος. Ακόμα και αν το σύστημα μπορεί
       να λειτουργήσει καλύτερα από το σημείο τέλειας απόδοσης, ο πελάτης δεν μπορεί
       να αξιοποιήσει αυτήν την δυναμικότητα. Για παράδειγμα, ένα κοινωνικό δίκτυο
       που υποστηρίζει περισσότερα μέλη από τον παγκόσμιο πληθυσμό θα είχε αυτήν
       την υπερβολική δυναμικότητα.
    2. Σημείο αποτυχίας - Αυτό είναι το πλέον ανεπιθύμητο επίπεδο απόδοσης, πέρα
       από το οποίο δεν υπάρχει περαιτέρω μείωση στο όφελος. Για παράδειγμα, το
       κοινωνικό δίκτυο μπορεί να χρειάζεται να υποστηρίξει τουλάχιστον ένα ελάχιστο
       μερίδιο στην αγορά για να είναι επικερδές ως πλατφόρμα.

Ένα ποσοτικοποιημένο σημείο απαίτησης, ακόμη κι αν αναφέρεται ρητά, συνήθως
είναι αυθαίρετο. Συχνά βασίζεται σε αυτό που αισθάνεται να ζητήσει
δικαιολογημένα ένας πελάτης, λαμβάνοντας υπόψη την αξία που καταβάλλει για το
λογισμικό. Ακόμα και αν οι μηχανικοί λογισμικού δεν μπορούν να κατασκευάσουν
ένα σύστημα που να ικανοποιεί πλήρως το αναφερόμενο σημείο απαίτησης, το
λογισμικό συνήθως εξακολουθεί να έχει αξία. Απλά έχει λιγότερη αξία από αυτήν
που περίμενε ο πελάτης. Επιπλέον, η ικανότητα υπέρβασης του σημείου απαίτησης
μπορεί να αυξήσει σημαντικά την αξία σε ορισμένες περιπτώσεις.

Το κόστος για να επιτευχθεί ένα συγκεκριμένο επίπεδο επίδοσης είναι συνήθως μια
βαθμιδωτή συνάρτηση. Αρχικά, για ένα συγκεκριμένο επίπεδο επένδυσης,
υπάρχει ένα μέγιστο εφικτό επίπεδο επίδοσης. Στη συνέχεια, απαιτείται
επιπλέον επένδυση, και αυτή η επιπλέον επένδυση επιτρέπει την επίδοση έως ένα
νέο, πιο επιθυμητό μέγιστο. Η Εικόνα 1.5 απεικονίζει το επίπεδο επίδοσης με τον
πλέον οικονομικό τρόπο - το επίπεδο επίδοσης με τη μέγιστη θετική διαφορά
μεταξύ της αξίας σε αυτό το επίπεδο επίδοσης και του κόστους για την
επίτευξή του.

{id="fig-softreq-costeffectivefunction"}

![Σχήμα 1.5 Το πιο οικονομικά αποδοτικό επίπεδο επίδοσης.](images/1.5-SoftReq.png)

(βλ. γνωστικό πεδίο των οικονομικών τεχνολογίας λογισμικού για περισσότερες
πληροφορίες σχετικά με τη διεξαγωγή οικονομικών αναλύσεων όπως αυτή.)

Ο μηχανικός λογισμικού θα πρέπει να δώσει ιδιαίτερη προσοχή στις θετικές και
αρνητικές σχέσεις μεταξύ των περιορισμών ποιότητας υπηρεσίας
(π.χ. εικόνα 14-2). Ορισμένοι περιορισμοί ποιότητας υπηρεσίας
αλληλοϋποστηρίζονται, δηλαδή η βελτίωση του επιπέδου επίδοσης του ενός θα
βελτιώσει αυτόματα το επίπεδο επίδοσης του άλλου. Για παράδειγμα, όσο πιο
τροποποιήσιμος είναι ο κώδικας, τόσο πιο αξιόπιστος είναι, καθώς η
τροποποιησιμότητα και η αξιοπιστία είναι, σε έναν βαθμό, αποτέλεσμα του πόσο
καθαρός είναι ο κώδικας. Από την άλλη πλευρά, όσο υψηλότερη είναι η ταχύτητα
του κώδικα, τόσο λιγότερο τροποποιήσιμος μπορεί να είναι, επειδή η υψηλή
ταχύτητα συχνά επιτυγχάνεται μέσω βελτιστοποιήσεων που καθιστούν τον κώδικα
πιο περίπλοκο.

### *Τυπική ανάλυση* {#formal-analysis}

Η τυπική ανάλυση παρουσιάζει οφέλη σε ορισμένους τομείς εφαρμογής,
ειδικά σε συστήματα υψηλής ακεραιότητας. Η επίσημη έκφραση των
απαιτήσεων εξαρτάται από τη χρήση μιας γλώσσας προδιαγραφής με επίσημα
καθορισμένους συμβολισμούς. Η τυπική ανάλυση έχει δύο οφέλη. Πρώτον, οι
τυπικές απαιτήσεις είναι ακριβείς και συνοπτικές, που (στη θεωρία)
θα μειώσει τη πιθανότητα παρερμηνείας. Δεύτερον, οι απαιτήσεις μπορούν να
αιτιολογηθούν, επιτρέποντας να αποδειχθούν επιθυμητές ιδιότητες του
καθορισμένου λογισμικού. Αυτό επιτρέπει τη στατική επικύρωση πως το λογισμικό,
που διαμορφώνεται από τις απαιτήσεις, έχει πράγματι τις ιδιότητες που ο
πελάτης, οι χρήστες, και ο μηχανικός λογισμικού προσδοκούν να έχει
(για παράδειγμα, την απουσία αδιεξόδου).

Το θέμα αυτό σχετίζεται επίσης με τις Τυπικές μεθόδους
στο γνωστικό πεδίο Μοντέλα και μέθοδοι τεχνολογίας λογισμικού.

### *Αντιμετώπιση συγκρούσεων στις απαιτήσεις*

Όταν ένα έργο έχει περισσότερα - και πιο διαφορετικά - ενδιαφερόμενα μέρη,
είναι πιο πιθανό να υπάρχουν συγκρούσεις μεταξύ των απαιτήσεων. Ένα ιδιαίτερα
σημαντικό κομμάτι της ανάλυσης απαιτήσεων είναι η αναγνώριση και διαχείριση
τέτοιων συγκρούσεων. Αφού αναγνωριστούν οι αντιφατικές απαιτήσεις,
ο μηχανικός μπορεί να εξετάσει δύο διαφορετικές προσεγγίσεις για
τη διαχείριση της σύγκρουσης (και πιθανώς και άλλες προσεγγίσεις) και να
καθορίσει τον καταλληλότερο τρόπο δράσης.

Μία προσέγγιση είναι να διαπραγματευτεί μια επίλυση μεταξύ των ενδιαφερόμενων
μερών που έρχονται σε αντιπαράθεση. Στις περισσότερες περιπτώσεις, δεν είναι
σοφό για τον μηχανικό λογισμικού να παίρνει μια μονομερή απόφαση, έτσι ώστε
να καθίσταται αναγκαία η διαβούλευση με τα ενδιαφερόμενα μέρη για
να επιτευχθεί συναίνεση για ένα κατάλληλο αντιστάθμισμα. Συνήθως είναι
πολύ σημαντικό, για συμβατικούς λόγους, τέτοιου είδους αποφάσεις να
είναι ανιχνεύσιμες από τον πελάτη. Ένα συγκεκριμένο παράδειγμα είναι
η *διαχείριση του εύρους του έργου* - δηλαδή, την εύρεση ισορροπίας μεταξύ
αυτού που επιθυμείται στις αναφερόμενες απαιτήσεις του προϊόντος λογισμικού
και αυτού που μπορεί να επιτευχθεί δεδομένων των απαιτήσεων του έργου για
κόστος, προγραμματισμό, προσωπικό και άλλους περιορισμούς σε επίπεδο έργου.
Υπάρχουν πολλές χρήσιμες πηγές για πληροφορίες σχετικά με τις διαπραγματεύσεις
και την επίλυση συγκρούσεων.

Μια άλλη προσέγγιση είναι η εφαρμογή της *ανάπτυξης οικογένειας προϊόντων* (π.χ.
[20]). Η οποία περιλαμβάνει τη διαίρεση των απαιτήσεων σε δύο κατηγορίες. Η
πρώτη κατηγορία περιλαμβάνει τις *σταθερές απαιτήσεις* (invariants). Αυτές είναι
απαιτήσεις στις οποίες συμφωνούν όλα τα ενδιαφερόμενα μέρη. Η δεύτερη κατηγορία
περιλαμβάνει τις *μεταβλητές απαιτήσεις* (variants), όπου υπάρχει σύγκρουση.
Ο μηχανικός λογισμικού μπορεί να επικεντρωθεί στην κατανόηση του εύρους των
παραλλαγών που απαιτούνται για να ικανοποιηθούν όλα τα ενδιαφερόμενα μέρη.
Το λογισμικό μπορεί να σχεδιαστεί χρησιμοποιώντας την
*σχεδίαση με βάση αμετάβλητες συνθήκες* (design to invariants), ώστε να
ενσωματωθούν οι σταθερές απαιτήσεις και τον *σχεδιασμό για αλλαγή* για να
συμπεριλάβει σημεία προσαρμογής για τη διαμόρφωση μιας εκδοχής του
συστήματος που ταιριάζει καλύτερα στα σχετικά ενδιαφερόμενα μέρη. Ένα απλό
παράδειγμα, ορισμένοι χρήστες μιας εφαρμογής καιρού απαιτούν να εμφανίζονται οι
θερμοκρασίες σε βαθμούς Κελσίου, ενώ άλλοι απαιτούν βαθμούς Φαρενάιτ.

## **Προσδιορισμός απαιτήσεων** {#req-specif}

Ο *προσδιορισμός απαιτήσεων* αφορά την καταγραφή των απαιτήσεων, ώστε να μπορούν
να αποθηκευτούν και να μεταδοθούν. Ο προσδιορισμός απαιτήσεων μπορεί να είναι
το πιο συζητημένο θέμα σε αυτή το γνωστικό πεδίο. Ο διάλογος επικεντρώνεται
σε ερωτήσεις, όπως:

    * πρέπει να καταγραφούν οι απαιτήσεις;
    * εάν καταγραφούν οι απαιτήσεις, ποια μορφή πρέπει να έχουν;
    * εάν καταγραφούν οι απαιτήσεις, πρέπει να διατηρούνται διαχρονικά;

Δεν υπάρχουν συγκεκριμένες απαντήσεις σε αυτές τις ερωτήσεις. Η απάντηση σε
κάθε μία μπορεί να εξαρτάται από παράγοντες, όπως:

    * η εξοικείωση του μηχανικού λογισμικού με τον επιχειρηματικό κλάδο,
    * το προηγούμενο για αυτόν τον τύπο λογισμικού,
    * o βαθμός κινδύνου (π.χ. πιθανότητα, σοβαρότητα) λάθος απαιτήσεων,
    * την αναμενόμενη κινητικότητα προσωπικού κατά τη διάρκεια της υπηρεσιακής
    ζωής του λογισμικού,
    * η γεωγραφική κατανομή των μελών της ομάδας ανάπτυξης,
    * η συμμετοχή των ενδιαφερόμενων μερών κατά τη διάρκεια του έργου,
    * εάν αναμένεται η χρήση τυποποιημένου λογισμικού ή βιβλιοθήκης ανοικτού κώδικα,
    * εάν πρόκειται να γίνει εξωτερική ανάθεση κάποιου σχεδιασμού ή κατασκευής,
    * ο αναμενόμενος βαθμός ελέγχου βασισμένου σε απαιτήσεις,
    * η προσπάθεια που απαιτείται για τη χρήση μιας τεχνικής προσδιορισμού υποψήφιου,
    * η ακρίβεια που απαιτείται από τις εκτιμήσεις βασισμένες σε απαιτήσεις,
    * ο βαθμός ιχνηλασιμότητας απαιτήσεων που απαιτείται, εάν απαιτείται,
    * οι συμβατικές επιβαρύνσεις του περιεχομένου και της μορφής προδιαγραφών
    απαιτήσεων.

Όπως αναφέρεται στην εισαγωγή του παρόντος γνωστικού πεδίου, τα *τι* και *πώς*
της δουλειάς των απαιτήσεων λογισμικού σε ένα έργο πρέπει να καθοριστούν από τη
φύση του κατασκευαζόμενου λογισμικού, όχι από τον κύκλο ζωής κάτω από τον οποίο
κατασκευάζεται. Οι μελλοντικοί συντηρητές δεν θα πρέπει να μπορούν να
αντιληφθούν τον κύκλο ζωής που χρησιμοποιήθηκε στην προηγούμενη ανάπτυξη μόνο
από τη μορφή αυτών των απαιτήσεων. Ο αντίκτυπος του επιλεγμένου κύκλου ζωής
πρέπει να περιορίζεται στην πληρότητα των απαιτήσεων σε οποιοδήποτε σημείο του
έργου. Σε έναν κύκλο ζωής καταρράκτη, αναμένεται να καθοριστούν πλήρως οι
απαιτήσεις στο τέλος της φάσης των απαιτήσεων. Σε έναν ευέλικτο κύκλο ζωής,
αναμένεται να αλλάζουν, να αυξάνονται ή να απορρίπτονται οι απαιτήσεις διαρκώς
και να μην είναι πλήρεις μέχρι το τέλος του έργου.

Ορισμένοι οργανισμοί έχουν μια κουλτούρα τεκμηρίωσης απαιτήσεων, ενώ άλλοι
όχι. Δυναμικά νεοφυή πρότζεκτ συχνά κινούνται από ένα ισχυρό προϊοντικό
όραμα και περιορισμένους πόρους. Οι ομάδες τους μπορεί να θεωρούν την
τεκμηρίωση απαιτήσεων ως περιττή επιβάρυνση. Ωστόσο, καθώς αυτά τα προϊόντα
εξελίσσονται και ωριμάζουν, οι μηχανικοί λογισμικού συχνά αναγνωρίζουν ότι
χρειάζεται να ανακτήσουν τις απαιτήσεις που ενέπνευσαν τα χαρακτηριστικά του
προϊόντος προκειμένου να αξιολογήσουν την επίδραση των προτεινόμενων αλλαγών.
Επομένως, η τεκμηρίωση των απαιτήσεων και η διαχείριση των αλλαγών γίνονται
σημαντικές για τη μακροπρόθεσμη επιτυχία. Η προσέγγιση ενός έργου ως προς τις
απαιτήσεις γενικά και την προδιαγραφή απαιτήσεων ειδικότερα, μπορεί να
εξελιχθεί κατά τη διάρκεια της διάρκειας ζωής του λογισμικού.

Η πιο βασική συμβουλή για την τεκμηρίωση των απαιτήσεων είναι να βασίζεται σε
μια *ανάλυση κοινού*. Ποιοι είναι οι διαφορετικοί καταναλωτές που θα
χρειαστούν πληροφορίες από μια προδιαγραφή απαιτήσεων; Ποιες πληροφορίες θα
χρειαστούν; Πώς μπορούν αυτές οι πληροφορίες να συσκευαστούν και να
παρουσιαστούν έτσι ώστε κάθε καταναλωτής να λαμβάνει τις πληροφορίες που
χρειάζεται με την ελάχιστη προσπάθεια;

Υπάρχει ένας βαθμός επικάλυψης και εξάρτησης μεταξύ ανάλυσης και προδιαγραφής
απαιτήσεων. Η χρήση συγκεκριμένων τεχνικών προδιαγραφής απαιτήσεων - ειδικότερα
τεχνικών προδιαγραφής απαιτήσεων βασισμένων σε μοντέλα - επιτρέπει και
ενθαρρύνει την ανάλυση απαιτήσεων που μπορεί να υπερβαίνει αυτό που έχει
ήδη παρουσιαστεί.

Οι καταγεγραμμένες απαιτήσεις λογισμικού πρέπει να υπόκεινται στις ίδιες
πρακτικές διαχείρισης σχηματισμών με τα άλλα παραδοτέα των διαδικασιών του
κύκλου ζωής του λογισμικού. (βλ. το γνωστικό πεδίο της διαχείρισης σχηματισμών
για μια λεπτομερή συζήτηση.) Επιπλέον, όταν είναι πρακτικό, οι μεμονωμένες
απαιτήσεις υπόκεινται επίσης σε διαχείριση σχηματισμών, η οποία υποστηρίζεται
γενικά από ένα εργαλείο διαχείρισης απαιτήσεων. (βλ. εργαλεία
απαιτήσεων λογισμικού.)

Υπάρχουν αρκετές γενικές κατηγορίες τεχνικών προδιαγραφής απαιτήσεων, κάθε μία
από τις οποίες συζητείται παρακάτω. Η προδιαγραφή απαιτήσεων για ένα
συγκεκριμένο έργο μπορεί επίσης να χρησιμοποιεί διάφορες τεχνικές.
Το πρότυπο ISO/IEC/IEEE 29148 [26] και πολλά άλλα, προσφέρουν πρότυπα για
την τεκμηρίωση απαιτήσεων.

### *Αδόμητος προσδιορισμός απαιτήσεων σε φυσική γλώσσα*

Ο *προσδιορισμός απαιτήσεων σε φυσική γλώσσα* εκφράζει απαιτήσεις σε
κοινή, συνηθισμένη γλώσσα. Ο προσδιορισμός απαιτήσεων σε φυσική γλώσσα
μπορεί να είναι δομημένος ή αδόμητος.

Ένας τυπικός αδόμητος προσδιορισμός απαιτήσεων σε φυσική γλώσσα
είναι μια συλλογή
δηλώσεων σε φυσική γλώσσα, όπως "Το σύστημα θα πρέπει να ...".
Για παράδειγμα, οι επιχειρησιακοί κανόνες είναι
δηλώσεις που καθορίζουν ή περιορίζουν κάποιο
κομμάτι της δομής ή της συμπεριφοράς της επιχείρησης προς αυτοματοποίηση.
"Ένας φοιτητής δεν μπορεί να εγγραφεί στα μαθήματα του επόμενου εξαμήνου αν
υπάρχουν οποιεσδήποτε οφειλές διδάκτρων" είναι ένα παράδειγμα ενός
επιχειρησιακού κανόνα που λειτουργεί ως απαίτηση για το λογισμικό
εγγραφής μαθημάτων ενός πανεπιστημίου. Κάποια
έργα μπορούν να δημοσιεύουν ένα εγχειρίδιο χρήσης ως ικανοποιητικό
προσδιορισμός απαιτήσεων, αν και υπάρχουν περιορισμοί στο πόσο αποτελεσματικό
αυτό μπορεί να είναι (Βλ. επίσης [26]).

### *Δομημένος προσδιορισμός απαιτήσεων σε φυσική γλώσσα*

Ο δομημένος προσδιορισμός απαιτήσεων σε φυσική γλώσσα επιβάλλει
περιορισμούς στον τρόπο που εκφράζονται οι απαιτήσεις.
Ο στόχος είναι να αυξηθεί η ακρίβεια και η συνοπτικότητα.

Το πιο απλό παράδειγμα μπορεί να είναι η μορφή ηθοποιός-ενέργεια.
Ο ηθοποιός είναι η οντότητα που είναι υπεύθυνη για την εκτέλεση της
ενέργειας και η ενέργεια είναι αυτό που πρέπει να συμβεί. Ένα γεγονός
εκκίνησης μπορεί να προηγηθεί του ηθοποιού, και η ενέργεια μπορεί να
ακολουθείται από μια προαιρετική συνθήκη ή προϋπόθεση. Η δήλωση "Όταν
αποστέλλεται μια παραγγελία, το σύστημα θα δημιουργεί ένα τιμολόγιο,
εκτός αν οι όροι της παραγγελίας είναι 'Προπληρωμένο'" χρησιμοποιεί
τη μορφή ηθοποιός-ενέργεια. Το γεγονός εκκίνησης είναι "Όταν αποστέλλεται
μια παραγγελία". Ο ηθοποιός είναι "το σύστημα". Η ενέργεια είναι
"θα δημιουργεί ένα τιμολόγιο". Η συνθήκη/προϋπόθεση είναι "εκτός
αν οι όροι της παραγγελίας είναι 'Προπληρωμένο'".

Ένα άλλο παράδειγμα είναι ένα πρότυπο προσδιορισμού περίπτωσης χρήσης,
όπως φαίνεται στο Σχήμα 1.6 (Βλ. [11] για κατευθυντήριες γραμμές για
την άρτια συγγραφή προσδιορισμού περιπτώσεων χρήσης).

{id="fig-softreq-usecasespecification"}

![Σχήμα 1.6 Παράδειγμα δομημένου προσδιορισμού σε φυσική γλώσσα για μια περίπτωση χρήσης.](images/1.6-SoftReq.png)

Η μορφή ιστορίας
χρήστη, "Ως <χρήστης> θέλω <δυνατότητα> ώστε <ωφέλεια>" καθώς και
οι πίνακες απόφασης είναι άλλα παραδείγματα.

### *Προσδιορισμός απαιτήσεων βασισμένος σε κριτήρια αποδοχής*

Αυτή η γενική προσέγγιση περιλαμβάνει δύο συγκεκριμένες παραλλαγές:
την ανάπτυξη οδηγούμενη από τον έλεγχο αποδοχής (Acceptance Test Driven
Development ή ATDD) και την ανάπτυξη οδηγούμενη από τη συμπεριφορά (Behavior
Driven Development ή BDD).

Η ανάπτυξη οδηγούμενη από τον έλεγχο αποδοχής
είναι μέρος της ευρύτερης προσέγγισης ανάπτυξης οδηγούμενης από τον
έλεγχο (TDD). (βλ. γνωστικό πεδίο Έλεγχος λογισμικού). Η κύρια ιδέα
της TDD είναι ότι οι περιπτώσεις ελέγχου προηγούνται της
κατασκευής. Επομένως, δεν γράφεται νέος κώδικας στην παραγωγή και
δεν τροποποιείται υπάρχων κώδικας εκτός αν τουλάχιστον μία
περίπτωση ελέγχου αποτύχει, είτε στο επίπεδο των δοκιμών μονάδων
είτε στο επίπεδο των δοκιμών αποδοχής. Η διαδικασία της
ανάπτυξης οδηγούμενη από τον έλεγχο αποδοχής έχει τρία βήματα:

    1. Επιλέγεται μια λειτουργικότητα (π.χ. μια ιστορία χρήστη) για υλοποίηση.
    2. Ένας ή περισσότεροι μηχανικοί λογισμικού, ένας ή περισσότεροι ειδικοί
       του επιχειρηματικού πεδίου και πιθανότατα ένας ή περισσότεροι επαγγελματίες
       διασφάλισης ποιότητας/ελέγχου συναντιούνται - πριν γίνει οποιοσδήποτε
       σχεδιασμός παραγωγής ή εργασία κατασκευής - για να συμφωνήσουν σε ένα
       σύνολο περιπτώσεων ελέγχου που πρέπει να εκτελεστούν για να
       δείξουν ότι η λειτουργικότητα έχει υλοποιηθεί σωστά.
    3. Τουλάχιστον μια από αυτές τις περιπτώσεις ελέγχου αποδοχής πρέπει να
       αποτύχει στο υπάρχον λογισμικό. Η ύπαρξη τουλάχιστον μιας αποτυχημένης
       περίπτωσης ελέγχου δίνει στον ή στους μηχανικούς λογισμικού την άδεια να
       δημιουργήσουν ή να τροποποιήσουν τον κώδικα παραγωγής ώστε να περάσει όλες
       τις συμφωνηθέντες περιπτώσεις ελέγχου. Αυτό το βήμα μπορεί να απαιτήσει
       αρκετές επαναλήψεις. Κατά τη διάρκεια αυτού του βήματος, ο κώδικας ενδέχεται
       να υποστεί ανακατασκευή.

Όταν όλες οι περιπτώσεις ελέγχου αποδοχής έχουν περάσει και πιθανότατα όλες οι
περιπτώσεις ελέγχου μονάδας και ολοκλήρωσης επίσης, τότε η μονάδα
λειτουργικότητας θεωρείται ότι έχει υλοποιηθεί πλήρως και σωστά. Η διαδικασία
ATDD επιστρέφει στο βήμα 1, όπου επιλέγεται μια νέα μονάδα λειτουργικότητας
και ο κύκλος επαναλαμβάνεται.

Η ATDD μπορεί να φαίνεται μια τεχνική ελέγχου αντί για μια τεχνική καθορισμού
απαιτήσεων. Από την άλλη πλευρά, μια περίπτωση ελέγχου έχει τη γενική μορφή:
"Όταν δοθεί είσοδος που μοιάζει με το X, <u>αναμένουμε το λογισμικό να
παράγει</u> αποτελέσματα που μοιάζουν με το Y." Το κλειδί είναι η υπογραμμισμένη
φράση "αναμένουμε το λογισμικό να παράγει". Εάν απλώς τροποποιήσουμε αυτήν τη
φράση για να λέει "το λογισμικό θα πρέπει να παράγει", όπως στο: "Όταν δοθεί
είσοδος που μοιάζει με το X, <u>το λογισμικό θα πρέπει να παράγει</u>
αποτελέσματα που μοιάζουν με το Y", αυτό που πρώτα φαινόταν σαν περίπτωση
ελέγχου τώρα μοιάζει με απαίτηση. Τεχνικά, μια περίπτωση ελέγχου αποδοχής
μπορεί να καλύπτει περισσότερες από μία απλές απαιτήσεις, αλλά η γενική ιδέα
είναι ότι οι περιπτώσεις ελέγχου ATDD είναι ουσιαστικά ακριβείς και ξεκάθαρες
δηλώσεις απαιτήσεων.

Η προσέγγιση της BDD είναι κάπως πιο δομημένη και οι ειδικοί στον τομέα της
επιχείρησης την προτιμούν συνήθως αντί για την ATDD επειδή έχει λιγότερο
τεχνική εμφάνιση. Στη BDD, η μονάδα λειτουργικότητας περιγράφεται ως μια
ιστορία χρήστη, σε μια μορφή όπως αυτή: "Ως ένας <ρόλος>, θέλω
<στόχος/επιθυμία> ώστε <ωφέλεια>." Αυτό οδηγεί στον εντοπισμό και τον
προσδιορισμό ενός συνόλου "σεναρίων" σε αυτήν τη μορφή: "Δεδομένου
<κάποιου πλαισίου> [και <πιθανότατα επιπλέον πλαισίου>], όταν <έναυσμα>
τότε <αποτέλεσμα> [και <πιθανότατα περισσότερα αποτελέσματα>]."

Εάν η ιστορία είναι: "Ως πελάτης της τράπεζας, θέλω να κάνω ανάληψη χρημάτων
από το Αυτόματο Μηχάνημα Ανάληψης (ATM) ώστε να μπορώ να πάρω χρήματα χωρίς να
πηγαίνω στην τράπεζα", ένα σενάριο θα μπορούσε να είναι ότι "ο λογαριασμός έχει
ικανοποιητικό υπόλοιπο". Αυτό το σενάριο θα μπορούσε να παρουσιαστεί λεπτομερώς
ως εξής: "Δεδομένου ότι το υπόλοιπο του λογαριασμού είναι $500 και η τραπεζική
κάρτα του πελάτη είναι έγκυρη και το Αυτόματο Μηχάνημα Ανάληψης περιέχει αρκετά
χρήματα στο κουτί του, όταν ο κάτοχος λογαριασμού ζητά $100, τότε το ATM θα
πρέπει να βγάλει $100 και το υπόλοιπο του λογαριασμού θα πρέπει να είναι $400
και η τραπεζική κάρτα του πελάτη θα πρέπει να επιστραφεί".

Ένα άλλο σενάριο μπορεί να είναι ότι "ο λογαριασμός έχει ανεπαρκή υπόλοιπο" και
μπορεί να αναλυθεί ως εξής: "Δεδομένου ότι το υπόλοιπο του λογαριασμού είναι
$50 και η κάρτα του πελάτη είναι έγκυρη και το Αυτόματο Μηχάνημα Ανάληψης
περιέχει αρκετά χρήματα στο κουτί του, όταν ο κάτοχος του λογαριασμού ζητά
$100, τότε το ATM δεν πρέπει να εκδώσει χρήματα, και θα πρέπει να εμφανίσει ένα
μήνυμα ότι υπάρχει ανεπαρκές υπόλοιπο, το υπόλοιπο θα πρέπει να παραμείνει στα
$50 και η κάρτα του πελάτη θα πρέπει να επιστραφεί."

Ο στόχος της BDD είναι να υπάρχει ένα εμπεριστατωμένο σύνολο σεναρίων για κάθε
μονάδα λειτουργικότητας. Στην περίπτωση της ανάληψης μετρητών, θα χρειαζόταν
επιπλέον σενάρια για το "Η κάρτα του τραπεζικού πελάτη έχει απενεργοποιηθεί"
και το "Το ΑΤΜ δεν περιέχει αρκετά χρήματα στο κουτί του".

Οι περιπτώσεις ελέγχου αποδοχής είναι φανερές από τα σενάρια της BDD.

Ο προσδιορισμός απαιτήσεων που βασίζεται σε κριτήρια αποδοχής αντιμετωπίζει
άμεσα το πρόβλημα της ασάφειας των απαιτήσεων. Οι φυσικές γλώσσες είναι
από τη φύση τους αόριστες, αλλά η γλώσσα των περιπτώσεων ελέγχου δεν είναι.
Στον προσδιορισμό απαιτήσεων που βασίζεται σε κριτήρια αποδοχής, οι απαιτήσεις
γράφονται χρησιμοποιώντας τη γλώσσα των περιπτώσεων ελέγχου, η οποία είναι πολύ
ακριβής. Από την άλλη πλευρά, αυτό δεν λύνει από μόνο του το πρόβλημα της
έλλειψης πληρότητας. Ωστόσο, η συνδυασμένη χρήση της ATDD ή BDD με κατάλληλα
κριτήρια κάλυψης λειτουργικότητας, όπως ο έλεγχος πεδίου, η ανάλυση
ακραίων τιμών και τα ζεύγη ελέγχου (βλ. το γνωστικό πεδίο Έλεγχος
Λογισμικού), μπορεί να μειώσει την πιθανότητα μη πληρότητας των απαιτήσεων.

### *Προσδιορισμός απαιτήσεων βασισμένος σε μοντέλο*

Μια άλλη προσέγγιση για την αποφυγή της εγγενούς ασάφειας των φυσικών
γλωσσών είναι η χρήση γλωσσών μοντελοποίησης, όπως επιλεγμένα στοιχεία της
Ενοποιημένη Γλώσσα Μοντελοποίησης (UML) ή της γλώσσας μοντελοποίησης συστημάτων
(SysML). Όπως οι σχεδιαγράμματα που χρησιμοποιούνται στην κατασκευή κτιρίων,
έτσι και αυτές οι γλώσσες μοντελοποίησης μπορούν να χρησιμοποιηθούν με έναν
τρόπο που είναι ανεξάρτητος από την τεχνολογία υπολογιστών για να καθορίσουν με
ακρίβεια και συνοπτικότητα τις λειτουργικές απαιτήσεις. Αυτό το θέμα σχετίζεται
στενά με το γνωστικό πεδίο Μοντέλα και Μέθοδοι Μηχανικής Λογισμικού.
Τα μοντέλα απαιτήσεων εμπίπτουν σε δύο γενικές κατηγορίες:

    1. Δομικά μοντέλα για τον καθορισμό των πολιτικών που πρέπει να επιβάλλονται:
    Αυτά είναι λογικά μοντέλα κλάσης. Επίσης ονομάζονται εννοιολογικά μοντέλα
    δεδομένων και διαγράμματα οντοτήτων-συσχετίσεων.
    2. Μοντέλα συμπεριφοράς για τον καθορισμό των διαδικασιών που πρέπει να
    πραγματοποιηθούν: Αυτά τα μοντέλα περιλαμβάνουν μοντελοποίηση περιπτώσεων
    χρήσης, τα διαγράμματα αλληλεπίδρασης και καταστατική μοντελοποίηση.
    Άλλα παραδείγματα είναι τα διαγράμματα δραστηριοτήτων σε UML και
    η μοντελοποίηση ροής δεδομένων, όπως περιγράφεται στα [8], [10] και [18].

Οι προδιαγραφές απαιτήσεων βασισμένες σε μοντέλο διαφέρουν στο βαθμό
της μοντελοποίησης. Ας λάβουμε υπόψη τα εξής:

    * Η ευέλικτη μοντελοποίηση (Agile modeling) (βλ. για παράδειγμα [10]) είναι το
    λιγότερο τυπικό. Τα ευέλικτα μοντέλα μπορεί να είναι κάτι λίγο παραπάνω από
    πρόχειρα σχεδιαγράμματα των οποίων ο στόχος είναι να επικοινωνήσουν σημαντικές
    πληροφορίες αντί να δείξουν τη σωστή χρήση των σημειογραφιών μοντελοποίησης.
    Σε αυτόν τον τύπο μοντελοποίησης, το αποτέλεσμα της επικοινωνίας θεωρείται πιο
    σημαντικό από τη μορφή της επικοινωνίας.
    * Η ημιεπίσημη μοντελοποίηση, παρέχει έναν ορισμό των σημασιολογικών στοιχείων
    της γλώσσας μοντελοποίησης, αλλά αυτός ο ορισμός δεν έχει αποδειχθεί επίσημα
    ότι είναι πλήρης και συνεπής.
    * Η μοντελοποίηση με τη χρήση τυπικών μεθόδων, όπως η Ζ, η Μέθοδος Ανάπτυξης
    της Βιέννης (Vienna Development Method ή VDM), η Γλώσσα Περιγραφής και
    Προδιαγραφής (SDL) διαθέτουν πολύ ακριβώς καθορισμένη σημασιολογία που
    επιτρέπει την μηχανική ανάλυση των προδιαγραφών για την παρουσία ή την απουσία
    συγκεκριμένων ιδιοτήτων, προκειμένου να βοηθήσουν στην αποφυγή κρίσιμων λαθών
    στον συλλογισμό. Ο όρος *ορθότητα εκ κατασκευής* (correctness by construction)
    χρησιμοποιείται σε αυτό το πλαίσιο ανάπτυξης.
    (βλ. την ενότητα Τυπικές Μέθοδοι
    στην ενότητα Μοντέλα και Μέθοδοι Μηχανικής Λογισμικού.)

Γενικά, όσο πιο τυπικό είναι ένα μοντέλο απαιτήσεων, τόσο λιγότερο
αόριστο είναι, οπότε οι μηχανικοί λογισμικού έχουν λιγότερες πιθανότητες
να παρερμηνεύσουν τις απαιτήσεις. Τα πιο φορμαλιστικά μοντέλα απαιτήσεων
μπορούν επίσης:

    * να είναι πιο συνοπτικά και συμπαγή,
    * να είναι πιο εύκολα μεταφράσιμα σε κώδικα, ενδεχομένως
    μηχανικά,
    * να χρησιμοποιηθούν ως βάση για την παραγωγή των
    περιπτώσεων ελέγχου αποδοχής.

Ένα σημαντικό μήνυμα είναι ότι, ενώ οι τυπικές γλώσσες
μοντελοποίησης είναι πιο δυνατές από τις ημιεπίσημες και ευέλικτες
μοντελοποιήσεις, οι τυπικές σημειογραφίες μπορούν να επιβαρύνουν τόσο τον
δημιουργό του μοντέλου όσο και τους ανθρώπους που το διαβάζουν.
Η συμβιβαστική λύση της Wing είναι η χρήση τυπικά
καθορισμένων βάσεων (π.χ. στη Z) για επιφανειακό συντακτικό που
είναι πιο εύκολο στην ανάγνωση και την γραφή (π.χ. καταστατικά διαγράμματα UML).

### *Περαιτέρω ιδιότητες των απαιτήσεων*

Πέρα από τις βασικές δηλώσεις απαιτήσεων που έχουν ήδη περιγραφεί, η
τεκμηρίωση πρόσθετων χαρακτηριστικών για ορισμένες ή όλες τις απαιτήσεις
μπορεί να είναι χρήσιμη. Αυτές οι συμπληρωματικές λεπτομέρειες μπορούν να
βοηθήσουν τους μηχανικούς λογισμικού να ερμηνεύσουν και να διαχειριστούν
καλύτερα τις απαιτήσεις. Πιθανά επιπλέον χαρακτηριστικά περιλαμβάνουν τα εξής:

    * ετικέτα για υποστήριξη της ιχνηλασιμότητας των απαιτήσεων,
    * περιγραφή (περισσότερες λεπτομέρειες για την απαίτηση),
    * αιτιολογία (γιατί η απαίτηση είναι σημαντική),
    * πηγή (ρόλος ή όνομα του ενδιαφερόμενου μέρους που επέβαλε αυτήν την
    απαίτηση),
    * περίπτωση χρήσης ή σχετικού γεγονότος που δίνει το έναυσμα,
    * τύπος (ταξινόμηση ή κατηγορία της απαίτησης - για παράδειγμα, λειτουργική,
    ποιότητα υπηρεσίας),
    * εξαρτήσεις,
    * αντιθέσεις,
    * κριτήρια αποδοχής,
    * προτεραιότητα (βλ. Ιεράρχηση απαιτήσεων αργότερα στο παρόν γνωστικό πεδίο),
    * σταθερότητα (βλ. Σταθερότητα και μεταβλητότητα απαιτήσεων
    αργότερα στο παρόν γνωστικό πεδίο),
    * εάν η απαίτηση είναι κοινή ή μια παραλλαγή για την ανάπτυξη οικογένειας
    προϊόντων),
    * υλικά υποστήριξης,
    * ιστορικό αλλαγών της απαίτησης.

Η Γλώσσα Πλάνου (Planguage) του Gilb [7] συνιστά χαρακτηριστικά όπως
κλίμακα, μέτρο, ελάχιστο, στόχος, εξαίρετο, παρελθόν, τάση και αρχείο.

### *Εξελικτικός και ολοκληρωμένος προσδιορισμός απαιτήσεων*

Τα έργα που τεκμηριώνουν ρητά τις απαιτήσεις ακολουθούν δύο προσεγγίσεις.
Η μια μπορεί να ονομαστεί *εξελικτικός προσδιορισμός*.
Σε αυτή την προσέγγιση, μια έκδοση του προσδιορισμού απαιτήσεων περιλαμβάνει
μόνο τις διαφορές - προσθήκες, τροποποιήσεις και διαγραφές - από την
προηγούμενη έκδοση. Ένα πλεονέκτημα αυτής της προσέγγισης είναι ότι μπορεί να
παράγει μικρότερο όγκο γραπτών προδιαγραφών.

Η άλλη προσέγγιση μπορεί να ονομαστεί *ολοκληρωμένος προσδιορισμός*. Σε αυτήν
την προσέγγιση, ο προσδιορισμός απαιτήσεων κάθε έκδοσης περιλαμβάνει όλες τις
απαιτήσεις, όχι μόνο τις αλλαγές από την προηγούμενη έκδοση. Ένα πλεονέκτημα
αυτής της προσέγγισης είναι ότι ένας αναγνώστης μπορεί να κατανοήσει όλες τις
απαιτήσεις σε ένα μόνο έγγραφο, αντί να πρέπει να παρακολουθεί συνεχώς τις
συσσωρευτικές προσθήκες, τροποποιήσεις και διαγραφές ανάμεσα σε μια σειρά
προδιαγραφών.

Ορισμένοι οργανισμοί συνδυάζουν αυτές τις δύο προσεγγίσεις, παράγοντας
ενδιάμεσες εκδόσεις (π.χ. x.1, x.2 και x.3) που καθορίζονται αυξητικά και
κύριες εκδόσεις (π.χ. 1.0, 2.0 και 3.0) που καθορίζονται ολοκληρωμένα. Ο
αναγνώστης δεν χρειάζεται ποτέ να ανατρέξει πιο πίσω από τις
προδιαγραφές απαιτήσεων της τελευταίας κύριας έκδοσης για να αποκτήσει τον
πλήρη σύνολο προδιαγραφών.

## **Επικύρωση απαιτήσεων** {#validreq}

Η *επικύρωση απαιτήσεων* αφορά την απόκτηση εμπιστοσύνης ότι οι απαιτήσεις
αντιπροσωπεύουν τις πραγματικές ανάγκες των ενδιαφερόμενων μερών, όπως αυτές
κατανοούνται επί του παρόντος (και πιθανόν έχουν καταγραφεί). Καίρια
ερωτήματα περιλαμβάνουν τα ακόλουθα:

    * αντιπροσωπεύουν αυτές όλες τις απαιτήσεις που είναι σχετικές αυτή τη στιγμή;
    * υπάρχουν κάποιες δηλωμένες απαιτήσεις που δεν αντιπροσωπεύουν τις ανάγκες
    των ενδιαφερομένων;
    * είναι αυτές οι απαιτήσεις διατυπωμένες κατάλληλα;
    * είναι οι απαιτήσεις κατανοητές, συνεπείς και πλήρεις;
    * συμμορφώνεται η τεκμηρίωση των απαιτήσεων με τα σχετικά πρότυπα;

Τρεις μέθοδοι που συνήθως χρησιμοποιούνται για την επικύρωση των απαιτήσεων
είναι: οι αναθεωρήσεις απαιτήσεων, η προσομοίωση και εκτέλεση, και η υλοποίηση
πρωτοτύπων.

### *Επιθεώρηση απαιτήσεων* {#review-req}

Ο πιο κοινός τρόπος επικύρωσης είναι μέσω της αναθεώρησης ή επιθεώρησης ενός
εγγράφου απαιτήσεων. Ένας ή περισσότεροι επιθεωρητές καλούνται να εντοπίσουν
σφάλματα, παραλείψεις, μη έγκυρες υποθέσεις, έλλειψη σαφήνειας και απόκλιση από
την αποδεκτή πρακτική. Η επιθεώρηση από πολλαπλές οπτικές γωνίες προτιμάται:

    * οι πελάτες και οι χρήστες ελέγχουν αν οι επιθυμίες και οι ανάγκες
    τους αντιπροσωπεύονται πλήρως και ακριβώς,
    * άλλοι μηχανικοί λογισμικού με ειδίκευση στον προσδιορισμό απαιτήσεων ελέγχουν
    αν το έγγραφο είναι σαφές και συμμορφώνεται με τα ισχύοντα πρότυπα,
    * μηχανικοί λογισμικού που θα εκτελέσουν την αρχιτεκτονική, τον σχεδιασμό ή την
    κατασκευή του λογισμικού που θα ικανοποιεί αυτές τις απαιτήσεις ελέγχουν αν το
    έγγραφο είναι επαρκές για να υποστηρίξει το έργο τους.

Η παροχή λίστας ελέγχου, κριτηρίων ποιότητας ή ενός "ορισμού ολοκλήρωσης"
(definition of done) στους αναθεωρητές μπορεί να τους καθοδηγήσει να
επικεντρωθούν σε συγκεκριμένες πτυχές του προσδιορισμού απαιτήσεων.
(βλ. Επιθεωρήσεις και έλεγχο στο γνωστικό πεδίο της Ποιότητας λογισμικού.)

### *Προσομοίωση και εκτέλεση*

Τα μη εξειδικευμένα ενδιαφερόμενα μέρη ενδέχεται να μην θέλουν να αφιερώσουν
χρόνο για λεπτομερή επιθεώρηση ενός τεχνικού εγγράφου απαιτήσεων. Ορισμένες
προδιαγραφές μπορούν να υποβληθούν σε προσομοίωση ή πραγματική εκτέλεση αντί ή
επιπλέον της ανθρώπινης αναθεώρησης. Στον βαθμό που οι απαιτήσεις
προσδιορίζονται επίσημα (π.χ. σε έναν προσδιορισμό βασισμένο σε
μοντέλο), οι μηχανικοί λογισμικού μπορούν να ερμηνεύσουν αυτήν την προδιαγραφή
και να "εκτελέσουν" την προδιαγραφή. Δεδομένου ενός επαρκούς συνόλου σεναρίων
επίδειξης, τα ενδιαφερόμενα μέρη μπορούν να πειστούν ότι ο προσδιορισμός
καθορίζει τις πολιτικές και τις διαδικασίες τους πλήρως και ακριβώς.

### *Υλοποίηση πρωτοτύπου* {#prototyping}

Εάν ο προσδιορισμός απαιτήσεων δεν είναι σε μια μορφή που επιτρέπει την άμεση
προσομοίωση ή εκτέλεση, μια εναλλακτική λύση είναι η ανάθεση σε έναν μηχανικό
λογισμικού της κατασκευής ενός πρωτότυπο που δείχνει συγκεκριμένα κάποια
σημαντική διάσταση μιας υλοποίησης. Αυτό δείχνει τον τρόπο που ερμήνευσε αυτές
τις απαιτήσεις ο μηχανικός λογισμικού.

Τα πρωτότυπα μπορούν να βοηθήσουν να αποκαλυφθούν οι υποθέσεις των μηχανικών
λογισμικού και, εφόσον είναι απαραίτητο, να δώσουν χρήσιμη ανατροφοδότηση για
το γιατί κάνουν λάθος. Για παράδειγμα, η δυναμική συμπεριφορά μιας διεπαφής
χρήστη μπορεί να κατανοηθεί καλύτερα μέσω ενός κινούμενου πρωτοτύπου παρά μέσω
ενός περιγραφικού κειμένου ή γραφικών μοντέλων. Ωστόσο, ένας κίνδυνος της
υλοποίηση πρωτοτύπου είναι ότι θέματα εμφάνισης ή προβλήματα ποιότητας με το
πρωτότυπο μπορεί να αποσπάσουν την προσοχή των επιθεωρητών από την κεντρική
λειτουργικότητα του πρωτότυπου. Τα πρωτότυπα μπορεί επίσης να είναι δαπανηρά
στην ανάπτυξή τους. Ωστόσο, εάν ένα πρωτότυπο βοηθά τους μηχανικούς να
αποφύγουν την σπατάλη που προκαλείται από την προσπάθεια να ικανοποιήσουν
λανθασμένες απαιτήσεις, η δαπάνη του μπορεί να δικαιολογηθεί πιο εύκολα.

## **Δραστηριότητες διαχείρισης απαιτήσεων**

Η ανάπτυξη απαιτήσεων, συνολικά, μπορεί να θεωρηθεί ως «η επίτευξη συμφωνίας
για το ποιο λογισμικό πρόκειται να κατασκευαστεί» (βλ. Σχήμα 1.3). Αντίθετα,
η διαχείριση απαιτήσεων μπορεί να θεωρηθεί ως «η διατήρηση αυτής της
συμφωνίας με την πάροδο του χρόνου». Αυτό το θέμα εξετάζει τη διαχείριση
απαιτήσεων.

### *Ελαχιστοποίηση απαιτήσεων*

Ο στόχος της ελαχιστοποίηση απαιτήσεων είναι να βρεθεί το μικρότερο
σύνολο απλά δηλωμένων απαιτήσεων που θα ικανοποιήσει τις ανάγκες
των ενδιαφερόμενων μερών. Με αυτόν τον τρόπο θα μειωθεί ο όγκος και η
πολυπλοκότητα της λύσης, μειώνοντας έτσι την προσπάθεια, το κόστος και το
χρονοδιάγραμμα για την παράδοσή της. Η ελαχιστοποίηση απαιτήσεων περιλαμβάνει
την εξάλειψη απαιτήσεων που:

    * είναι εκτός του πεδίου εφαρμογής,
    * δεν θα παρήγαγαν επαρκή απόδοση στην επένδυση,
    * δεν είναι τόσο σημαντικές.

Ένα άλλο σημαντικό μέρος της διαδικασίας είναι η απλοποίηση απαιτήσεων που
είναι περιττά περίπλοκες.

Στους κύκλους ζωής της μεθόδου του καταρράκτη και άλλων μεθόδων που έχουν ως
βάση ένα σχέδιο, η ελαχιστοποίηση απαιτήσεων μπορεί να συντονιστεί με τις
επιθεωρήσεις των απαιτήσεων για την επικύρωσή τους· η ελαχιστοποίηση πρέπει να
πραγματοποιείται λίγο πριν από την επιθεώρηση επικύρωσης. Στους ευέλικτους
κύκλους ζωής, η ελαχιστοποίηση γίνεται αυτομάτως κατά τον σχεδιασμό των
επαναλήψεων· μόνο οι απαιτήσεις υψηλότερης προτεραιότητας εισέρχονται σε μια
επανάληψη (sprint).

### *Έλεγχος αλλαγών απαιτήσεων*

Ο έλεγχος αλλαγών είναι κεντρικός για τη διαχείριση των απαιτήσεων. Αυτό το
θέμα συνδέεται στενά με το γνωστικό πεδίο της Διαχείρισης σχηματισμών
λογισμικού. (Ανατρέξτε σε αυτό το κεφάλαιο για περισσότερες πληροφορίες)

Τα έργα που χρησιμοποιούν τον κύκλο ζωής του καταρράκτη ή άλλους βασιζόμενους
σε σχεδιασμό κύκλους ζωής πρέπει να έχουν έναν σαφή διαδικασία έλεγχου αλλαγών
απαιτήσεων που περιλαμβάνει:

    * έναν τρόπο για να ζητηθούν αλλαγές σε προηγουμένως συμφωνημένες απαιτήσεις,
    * ένα προαιρετικό στάδιο ανάλυσης επιπτώσεων για να εξεταστούν πιο λεπτομερώς
    τα οφέλη και το κόστος μιας ζητούμενης αλλαγής,
    * ένα υπεύθυνο άτομο ή ομάδα που αποφασίζει εάν θα αποδεχθεί, απορρίψει ή
    αναβάλλει κάθε ζητούμενη αλλαγή,
    * έναν τρόπο για να ειδοποιηθούν όλα τα επηρεαζόμενα ενδιαφερόμενα μέρη για
    αυτήν την απόφαση,
    * έναν τρόπο για να παρακολουθηθούν οι αποδεκτές αλλαγές μέχρι την ολοκλήρωσή
    τους.

Όλα τα ενδιαφερόμενα μέρη πρέπει να κατανοήσουν και να συμφωνήσουν ότι η
αποδοχή μιας αλλαγής σημαίνει αποδοχή των επιπτώσεών της στο πρόγραμμα, τους
πόρους και/ή μια ανάλογη αλλαγή στο εύρος κάπου αλλού στο έργο.

Αντίθετα, η διαχείριση των αλλαγών στις απαιτήσεις συμβαίνει αυτομάτως στους
ευέλικτους κύκλους ζωής. Σε αυτούς τους κύκλους ζωής, οποιοδήποτε αίτημα για
αλλαγή σε προηγουμένως συμφωνημένες απαιτήσεις γίνεται απλώς ένα ακόμη στοιχείο
στη λίστα ανεκτέλεστου προϊόντος (product backlog). Ένα αίτημα θα γίνει
«αποδεκτό» μόνο όταν τοποθετηθεί σε υψηλή προτεραιότητα και ενσωματωθεί σε
μια επανάληψη (ένα sprint).

### *Ταίριασμα εύρους*

Το *ταίριασμα εύρους* αφορά την εξασφάλιση ότι το εύρος των απαιτήσεων
για την αρχιτεκτονική, τον σχεδιασμό και την κατασκευή δεν υπερβαίνει κανέναν
περιορισμό σε κόστος, χρονοδιάγραμμα ή προσωπικό στο έργο. Όταν το εύρος των
απαιτήσεων υπερβαίνει τους περιορισμούς σε κόστος, χρονοδιάγραμμα ή προσωπικό,
τότε είτε πρέπει να μειωθεί αυτό το εύρος (πιθανόν αφαιρώντας αρκετές από τις
απαιτήσεις με χαμηλότερη προτεραιότητα), είτε πρέπει να αυξηθεί η δυνατότητα
(με την επέκταση του χρονοδιαγράμματος ή την αύξηση του προϋπολογισμού και/ή
του προσωπικού), ή πρέπει να διαπραγματευθεί κάποια κατάλληλη συνδυαστική
προσέγγιση των δύο.

Στον κύκλο ζωής του καταρράκτη και σε άλλους κύκλους ζωής βασισμένους σε σχέδιο,
το ταίριασμα εύρους μπορεί να συντονιστεί με την επικύρωση των απαιτήσεων· το
ταίριασμα εύρους πρέπει να γίνεται ακριβώς πριν από την αξιολόγηση επικύρωσης.
Σε ευέλικτους κύκλους ζωής, εφόσον γίνεται μια παραλλαγή του *σχεδιασμού
επανάληψης βασισμένου στην ταχύτητα*, τότε το μόνο έργο που επιτρέπεται
σε μια επανάληψη (sprint) είναι το έργο που αναμένεται οτι μπορεί λογικά να
ολοκληρωθεί κατά τη διάρκεια εκείνης της επανάληψης (sprint).

## **Πρακτικές θεωρήσεις**

### *Επαναληπτικός χαρακτήρας της διεργασίας απαιτήσεων*

Οι απαιτήσεις για τυπικό λογισμικό δεν έχουν μόνο ευρεία εμβέλεια, αλλά πρέπει
επίσης να έχουν σημαντικό βάθος. Η ένταση που προκαλείται από τις απαιτήσεις
που σχετίζονται τόσο με το εύρος όσο και το βάθος, σε πραγματικά έργα συχνά
παροτρύνει τις ομάδες να εκτελούν δραστηριότητες απαιτήσεων επαναληπτικά. Σε
ορισμένα σημεία, η εκμαίευση και η ανάλυση ευνοούν τη διεύρυνση του εύρους της
γνώσης των απαιτήσεων, ενώ σε άλλα σημεία, απαιτείται η διεύρυνση του βάθους.
Στην πράξη, είναι απίθανο να μπορεί να ολοκληρωθεί όλο το έργο των απαιτήσεων
με ένα μόνο πέρασμα του αντικειμένου.

### *Ιεράρχηση απαιτήσεων*

Η ιεράρχηση των απαιτήσεων είναι χρήσιμη καθ' όλη τη διάρκεια ενός έργου
λογισμικού, καθώς βοηθά στην εστίαση των μηχανικών λογισμικού στην παράδοση
των λειτουργιών που έχουν τη μεγαλύτερη αξία με τη μεγαλύτερη δυνατή ταχύτητα.
Επίσης, βοηθά στην υποστήριξη έξυπνων αποφάσεων συμβιβασμού που αφορούν την
επίλυση συγκρούσεων και το ταίριασμα εύρους. Οι ιεραρχημένες απαιτήσεις βοηθούν
επίσης στη συντήρηση πέρα από το ίδιο το αρχικό έργο ανάπτυξης. Πιθανόν οι
ατέλειες που αναφέρονται σε απαιτήσεις υψηλότερης προτεραιότητας να πρέπει
να διορθωθούν προτού διορθωθούν οι ατέλειες που αναφέρονται σε απαιτήσεις με
χαμηλότερη προτεραιότητα.

Υπάρχουν διάφορα διαγράμματα ιεράρχησης που είναι διαθέσιμα.
Η απάντηση σε μερικές καίριες ερωτήσεις μπορεί να βοηθήσει τους μηχανικούς
να επιλέξουν την καλύτερη προσέγγιση. Η πρώτη ερώτηση είναι "Ποιοι
παράγοντες είναι σημαντικοί για τον καθορισμό της προτεραιότητας μιας
απαίτησης έναντι μιας άλλης;" Οι παρακάτω παράγοντες θα μπορούσαν να
είναι σημαντικοί για ένα έργο:

    * αξία· επιθυμητότητα· ικανοποίηση πελάτη και χρήστη,
    * μη επιθυμητότητα· δυσαρέσκεια πελάτη και χρήστη (μοντέλο Kano, παρακάτω),
    * κόστος παράδοσης,
    * κόστος συντήρησης κατά τη διάρκεια της λειτουργίας του λογισμικού,
    * τεχνικός κίνδυνος υλοποίησης,
    * κίνδυνος ότι οι χρήστες δεν θα το χρησιμοποιήσουν, ακόμα κι αν υλοποιηθεί.

Το μοντέλο Kano δείχνει ότι η θεώρηση μόνο της αξία, της
επιθυμητότητας ή της ικανοποίησης μπορεί να οδηγήσει σε εσφαλμένες
προτεραιότητες. Μια καλύτερη κατανόηση των προτεραιοτήτων προκύπτει
από τον τρόπο που θα αντιδρούσαν τα ενδιαφερόμενα μέρη εάν αυτή η απαίτηση
δεν ικανοποιούνταν. Για παράδειγμα, ας υποθέσουμε ένα έργο για την ανάπτυξη
ενός προγράμματος ηλεκτρονικού ταχυδρομείου. Δύο προαιρετικές απαιτήσεις
μπορεί να αφορούν:

    1.  Την ύπαρξη αποτελεσματικού φίλτρου ανεπιθύμητων μηνυμάτων (spam)
    2.  Τον χειρισμό συνημμένων σε μηνύματα ηλεκτρονικού ταχυδρομείου

Η ιεράρχηση πρέπει να ζυγίσει τόσο την ικανοποίηση που θα νιώσουν οι χρήστες
από την παρουσία συγκεκριμένων λειτουργιών, όσο και τη δυσαρέσκεια που
θα νιώσουν εάν λείπουν συγκεκριμένες λειτουργίες. Για παράδειγμα, οι χρήστες
πιθανότατα θα είναι πιο ικανοποιημένοι με ένα αποτελεσματικό φίλτρο
ανεπιθύμητων μηνυμάτων (spam) παρά με τη δυνατότητα χειρισμού συνημμένων.
Έτσι, το φίλτρο ανεπιθύμητων μηνυμάτων θα έχει υψηλότερη προτεραιότητα βάσει
του κριτηρίου ικανοποίησης. Από την άλλη πλευρά, η αδυναμία χειρισμού
συνημμένων θα καθιστούσε πολλούς χρήστες ιδιαίτερα δυσαρεστημένους - πολύ
περισσότερο από το να μην υπάρχει ένα αποτελεσματικό φίλτρο ανεπιθύμητων
μηνυμάτων. Όταν λαμβάνουν υπόψη τη χαρά ή ικανοποίηση από την εφαρμογή
λειτουργιών σε συνδυασμό με τη δυσαρέσκεια από τη μη εφαρμογή συγκεκριμένων
λειτουργιών, οι προγραμματιστές θα δώσουν γενικά μεγαλύτερη προτεραιότητα
στον χειρισμό των συνημμένων από ό,τι στο αποτελεσματικό φίλτρο
ανεπιθύμητων μηνυμάτων.

Η δεύτερη καίρια ερώτηση είναι "Πώς μπορούμε να μετατρέψουμε το σύνολο των
σχετικών παραγόντων σε μια έκφραση προτεραιότητας;" Η φόρμουλα

{id="fig-softreq-formula"}

![](images/1.7-SoftReq.png)

είναι μόνο ένα παράδειγμα μιας *αντικειμενικής συνάρτησης* για τον
σκοπό αυτό. Η επιλογή των σχημάτων μέτρησης για τους σχετικούς παράγοντες
μπορεί να επιβάλει περιορισμούς στην αντικειμενική συνάρτηση. (Βλ.
Θεωρία της μέτρησης στην ενότητα Υπολογιστικά θεμέλια).

Μόλις έχει καθοριστεί η προτεραιότητα των απαιτήσεων, αυτές οι προτεραιότητες
πρέπει να καθοριστούν με έναν τρόπο που μπορεί να επικοινωνηθεί σε όλα τα
ενδιαφερόμενα μέρη. Υπάρχουν πολλοί τρόποι για να γίνει αυτό,
συμπεριλαμβανομένων των ακόλουθων:

    * τακτική κλίμακα (π.χ. απαραίτητο, θα έπρεπε να υπάρχει, ευπρόσδεκτο),
    * αριθμητική κλίμακα (π.χ. 1...10),
    * λίστες που ταξινομούν τις απαιτήσεις με φθίνουσα σειρά προτεραιότητας.

Η αποτελεσματική κατάταξη των απαιτήσεων επικεντρώνεται στον εντοπισμό ομάδων
απαιτήσεων με παρόμοιες προτεραιότητες, παρά στη δημιουργία υπερβολικά
αυστηρών κλιμάκων μέτρησης ή στη συζήτηση μικρών διαφορών.

### *Ιχνηλασιμότητα απαιτήσεων* {#tr-req}

Η *ιχνηλασιμότητα απαιτήσεων* μπορεί να εξυπηρετήσει δύο δυνητικά χρήσιμους
σκοπούς. Ένας από αυτούς είναι να λειτουργεί ως μια λογιστική καταχώριση που
καταγράφει τη συνέπεια μεταξύ ζεύγους σχετικών προϊόντων έργου. Ένα σημαντικό
ερώτημα μπορεί να είναι "Για κάθε αναγνωρισμένη απαίτηση λογισμικού, υπάρχουν
αναγνωρισμένα στοιχεία σχεδίασης που έχουν σκοπό να την ικανοποιήσουν;" Εάν
δεν μπορούν να βρεθούν αναγνωρισμένα στοιχεία σχεδίασης, τότε είτε αυτή η
απαίτηση δεν ικανοποιείται στον συγκεκριμένο σχεδιασμό είτε ο σχεδιασμός είναι
σωστός και μία ή περισσότερες αναφερόμενες απαιτήσεις μπορούν να διαγραφούν.
Με παρόμοιο τρόπο, "Για κάθε αναγνωρισμένο στοιχείο σχεδίασης, υπάρχουν
αναγνωρισμένες απαιτήσεις που προκαλούν την ύπαρξή του;" Εάν δεν μπορούν να
βρεθούν αναγνωρισμένες απαιτήσεις, τότε είτε αυτό το στοιχείο σχεδίασης είναι
περιττό είτε οι αναφερόμενες απαιτήσεις είναι ανεπαρκείς.

Ο άλλος σκοπός είναι να βοηθήσει στην ανάλυση των επιπτώσεων μιας προτεινόμενης
αλλαγής στις απαιτήσεις. Εάν μια συγκεκριμένη απαίτηση του συστήματος αλλάξει,
για παράδειγμα, αυτή η απαίτηση μπορεί να ανιχνευθεί στις συνδεδεμένες με αυτή
απαιτήσεις λογισμικού. Δεν χρειάζεται να αλλάξουν όλες οι συνδεδεμένες απαιτήσεις
λογισμικού. Ωστόσο, κάθε απαίτηση λογισμικού που θα επηρεαζόταν μπορεί να
ανιχνευθεί στα συνδεδεμένα με αυτή στοιχεία σχεδίασης. Ξανά, δεν χρειάζεται να
αλλάξουν όλα τα συνδεδεμένα στοιχεία σχεδίασης.

Αλλά κάθε στοιχείο σχεδίασης που επηρεάστηκε μπορούσε να ανιχνευθεί στον
σχετικό κώδικα. Οι επηρεαζόμενες απαιτήσεις λογισμικού, στοιχεία σχεδίασης
και μονάδες κώδικα μπορούσαν επίσης να ανιχνευθούν στις σχετικές τους
περιπτώσεις ελέγχου για περαιτέρω ανάλυση των επιπτώσεων. Αυτό βοηθά
στον καθορισμό ενός "αποτυπώματος" για τον όγκο της εργασίας που απαιτείται
για να ενσωματωθεί αυτή η αλλαγή στην απαίτηση του συστήματος.

Οι απαιτήσεις λογισμικού μπορούν να ανιχνευθούν στην πηγαία τεκμηρίωση,
όπως απαιτήσεις συστήματος, έγγραφα προδιαγραφών και άλλες σχετικές
προδιαγραφές. Οι απαιτήσεις λογισμικού μπορούν επίσης να ανιχνευθούν
μελλοντικά σε στοιχεία σχεδίασης και δοκιμασμένες απαιτήσεις. Τέλος, οι
απαιτήσεις λογισμικού μπορούν επίσης να ανιχνευθούν μελλοντικά σε ενότητες
ενός εγχειριδίου χρήστη που περιγράφουν την υλοποιημένη λειτουργικότητα.
(Βλ. επίσης [23])

### *Σταθερότητα και μεταβλητότητα απαιτήσεων*

Ορισμένες απαιτήσεις είναι πολύ σταθερές· πιθανόν να μην αλλάξουν ποτέ κατά
τη διάρκεια της υπηρεσίας του λογισμικού. Ορισμένες απαιτήσεις είναι λιγότερο
σταθερές· μπορεί να αλλάξουν κατά τη διάρκεια της υπηρεσίας, αλλά μπορεί να
μην αλλάξουν κατά τη διάρκεια του έργου ανάπτυξης. Για παράδειγμα, σε μια
τραπεζική εφαρμογή, οι απαιτήσεις για λειτουργίες υπολογισμού και πίστωσης
των τόκων στους λογαριασμούς των πελατών είναι πιθανόν να είναι πιο σταθερές
από τις απαιτήσεις για την υποστήριξη διαφορετικών λογαριασμών χωρίς φόρο. Οι
πρώτες αντικατοπτρίζουν μια θεμελιώδη χαρακτηριστική ιδιότητα του τραπεζικού
πεδίου (ότι οι λογαριασμοί μπορούν να εισπράττουν τόκους). Ταυτόχρονα, οι
δεύτερες μπορεί να καταστούν παρωχημένες από αλλαγή σε νομοθεσία της κυβέρνησης.
Τέλος, ορισμένες απαιτήσεις μπορεί να είναι πολύ ασταθείς· μπορεί να αλλάξουν
κατά τη διάρκεια του έργου - ίσως περισσότερες από μία φορές. Είναι χρήσιμο να
αξιολογηθεί η πιθανότητα μιας απαίτησης να αλλάξει σε δεδομένο χρονικό διάστημα.
Ο εντοπισμός πιθανώς ασταθών απαιτήσεων βοηθά τον μηχανικό λογισμικού να
καθιερώσει μια σχεδίαση πιο ανεκτή στην αλλαγή (π.χ. [20]).

### *Μέτρηση απαιτήσεων*

Ως πρακτικό θέμα, μπορεί να είναι χρήσιμο να έχουμε μια έννοια για τον *όγκο*
των απαιτήσεων για ένα συγκεκριμένο προϊόν λογισμικού. Αυτός ο αριθμός είναι
χρήσιμος για την αξιολόγηση του *μεγέθους* ενός νέου έργου ανάπτυξης ή του
μεγέθους μιας αλλαγής στις απαιτήσεις και για την εκτίμηση του κόστους
εργασιών ανάπτυξης ή συντήρησης, ή απλά για χρήση ως παρονομαστής σε
άλλες μετρήσεις. Η μέτρηση λειτουργικού μεγέθους (FSM) είναι
μια τεχνική για την αξιολόγηση του μεγέθους ενός συνόλου λειτουργικών
απαιτήσεων.

Πρόσθετες πληροφορίες σχετικά με τη μέτρηση μεγέθους και τα πρότυπα
μπορούν να βρεθούν στο γνωστικό πεδίο Διεργασία τεχνολογίας λογισμικού.

Έχουν αναπτυχθεί πολλοί δείκτες ποιότητας που μπορούν να χρησιμοποιηθούν για
να σχετίσουν την ποιότητα του προσδιορισμού των απαιτήσεων λογισμικού με άλλες
μεταβλητές του έργου, όπως το κόστος, η αποδοχή, η απόδοση, το πρόγραμμα και
η αναπαραγωγιμότητα. Οι δείκτες ποιότητας για μεμονωμένες απαιτήσεις
λογισμικού και ένα έγγραφο προδιαγραφής απαιτήσεων συνολικά μπορούν να
προκύψουν από τις επιθυμητές ιδιότητες που συζητήθηκαν στην παράγραφο 3.1,
Βασική ανάλυση απαιτήσεων, νωρίτερα σε αυτό το γνωστικό πεδίο.

### *Ποιότητα και βελτίωση των απαιτήσεων της διεργασίας ανάπτυξης*

Αυτό το θέμα αφορά την αξιολόγηση της ποιότητας και τη βελτίωση των απαιτήσεων
της διεργασίας ανάπτυξης. Ο σκοπός του είναι να τονίσει τον καίριο ρόλο της
διεργασίας ανάπτυξης στο κόστος και την έγκαιρη παράδοση ενός προϊόντος
λογισμικού και στην ικανοποίηση του πελάτη. Επιπλέον, βοηθά στον συντονισμό της
διεργασίας ανάπτυξης με πρότυπα ποιότητας και μοντέλα βελτίωσης διαδικασιών
για λογισμικό και συστήματα. Η ποιότητα και η βελτίωση της διεργασίας ανάπτυξης
σχετίζονται στενά τόσο με το γνωστικό πεδίο Ποιότητα λογισμικού όσο και με το
Κατηγορία Διεργασία τεχνολογίας λογισμικού και περιλαμβάνουν τα εξής:

    * κάλυψη της διαδικασίας απαιτήσεων από πρότυπα και μοντέλα βελτίωσης
    διεργασίας ανάπτυξης,
    * μέτρηση και σύγκριση της διεργασίας ανάπτυξης,
    * σχεδιασμός και εφαρμογή βελτιώσεων,
    * βελτίωση/σχεδιασμός και εφαρμογή ασφάλειας/CIA (εμπιστευτικότητα,
    ακεραιότητα και διαθεσιμότητα).

## **Εργαλεία απαιτήσεων λογισμικού** {#toolsreq}

Τα εργαλεία που βοηθούν τους μηχανικούς λογισμικού να αντιμετωπίζουν τις
απαιτήσεις λογισμικού κατατάσσονται ευρέως σε τρεις κατηγορίες: εργαλεία
διαχείρισης απαιτήσεων, εργαλεία μοντελοποίησης απαιτήσεων και εργαλεία
δημιουργίας λειτουργικών περιπτώσεων ελέγχου, όπως παρουσιάζονται παρακάτω.

### *Εργαλεία διαχείρισης απαιτήσεων*

Τα εργαλεία διαχείρισης απαιτήσεων υποστηρίζουν διάφορες δραστηριότητες,
συμπεριλαμβανομένης της αποθήκευσης των χαρακτηριστικών των απαιτήσεων,
του εντοπισμού, της δημιουργίας εγγράφων και του έλεγχου των αλλαγών.
Πράγματι, ο εντοπισμός και ο έλεγχος των αλλαγών μπορεί να είναι πρακτικοί
μόνο όταν υποστηρίζονται από ένα εργαλείο. Καθώς η διαχείριση απαιτήσεων
είναι θεμελιώδης για μια καλή πρακτική απαιτήσεων, πολλοί οργανισμοί έχουν
επενδύσει σε εργαλεία. Ωστόσο, πολλοί άλλοι διαχειρίζονται τις απαιτήσεις
τους με πιο αυθαίρετους και γενικά λιγότερο ικανοποιητικούς τρόπους
(π.χ. υπολογιστικοί πίνακες).

### *Εργαλεία μοντελοποίησης απαιτήσεων*

Ένα εργαλείο μοντελοποίησης απαιτήσεων υποστηρίζει τουλάχιστον τη δημιουργία,
τροποποίηση και δημοσίευση προδιαγραφών απαιτήσεων βασισμένων σε μοντέλα.
Ορισμένα εργαλεία επεκτείνουν αυτήν τη δυνατότητα παρέχοντας επίσης στατική
ανάλυση (π.χ., συντακτική ορθότητα, πληρότητα και συνέπεια). Η τυπική ανάλυση
απαιτεί υποστήριξη εργαλείων για να είναι εφαρμόσιμη για κάτι πέρα από απλά
συστήματα, και τα εργαλεία συνήθως χωρίζονται σε δύο κατηγορίες: τεκμηριωτές
θεωρίας ή ελεγκτές μοντέλων. Σε καμία από τις δύο περιπτώσεις  η
απόδειξη δεν μπορεί να είναι πλήρως αυτοματοποιημένη, καθώς και η επάρκεια
στην τυπική αιτιολόγηση που απαιτείται για τη χρήση των εργαλείων περιορίζει
την ευρύτερη τυπική ανάλυση. Ορισμένα εργαλεία εκτελούν επίσης δυναμικά μια
προδιαγραφή (προσομοίωση).

### *Εργαλεία παραγωγής περιπτώσεων λειτουργικών ελέγχων*

Όσο πιο ορισμένη τυπικά είναι μια γλώσσα προσδιορισμού απαιτήσεων, τόσο πιο
πιθανό είναι να μπορούν να παραχθούν τουλάχιστον εν μέρει μηχανικά λειτουργικές
περιπτώσεις ελέγχου. Για παράδειγμα, η μετατροπή σε περιπτώσεις ελέγχου
των σεναρίων BDD δεν είναι δύσκολη. Ένα άλλο παράδειγμα αφορά τα μοντέλα
κατάστασης. Θετικές περιπτώσεις ελέγχου μπορούν να προκύψουν για κάθε
καθορισμένη μετάβαση σε αυτόν τον τύπο μοντέλου. Αρνητικές περιπτώσεις ελέγχου
μπορούν να προκύψουν από τους συνδυασμούς κατάστασης και συμβάντος που δεν
εμφανίζονται. (Για περισσότερες πληροφορίες βλ. ενότητα 8.2, Εργαλεία
ελέγχου στην Ενότητα Έλεγχος Λογισμικού.)

Στην πιο γενική περίπτωση, τέτοια εργαλεία μπορούν μόνο να παράγουν εισόδους
για περιπτώσεις ελέγχου. Η καθορισμός ενός αναμενόμενου αποτελέσματος δεν
είναι πάντα δυνατός. Μπορεί να απαιτείται πρόσθετη ειδίκευση στον
επιχειρηματικό τομέα.